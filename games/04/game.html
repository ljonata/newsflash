<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Elf Quest</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
            user-select: none;
        }

        /* Top HUD bar */
        #hud {
            position: fixed; top: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.75);
            padding: 6px 12px;
            display: flex; justify-content: space-between; align-items: center;
            z-index: 200; height: 36px;
        }
        #hud-left { display: flex; align-items: center; gap: 12px; }
        #hud-left .username { color: gold; font-size: 13px; font-weight: bold; }
        #hud-left .coins { color: lime; font-size: 13px; }
        #hud-hearts { display: flex; gap: 3px; }
        .heart {
            width: 14px; height: 13px;
            background: #e94560;
            clip-path: polygon(50% 100%, 0% 35%, 15% 0%, 50% 20%, 85% 0%, 100% 35%);
        }
        .heart.empty { background: #444; }
        #hud-right a {
            color: #aaa; font-size: 13px; text-decoration: none; margin-left: 10px;
        }
        #hud-right a:hover { color: #fff; }

        /* Backpack panel */
        #backpack {
            width: 170px;
            background: rgba(20, 15, 10, 0.92);
            border-right: 3px solid #5d4037;
            padding-top: 40px;
            display: flex; flex-direction: column;
            z-index: 100;
            overflow-y: auto;
        }
        #backpack-title {
            text-align: center; color: #d4a574;
            font-size: 14px; font-weight: bold;
            padding: 8px; letter-spacing: 1px;
            border-bottom: 2px solid #3e2723;
        }
        #elf-portrait {
            width: 64px; height: 64px;
            margin: 10px auto;
            image-rendering: pixelated;
            border: 2px solid #5d4037;
            border-radius: 4px;
            background: #2e7d32;
        }
        .bp-item {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 10px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            color: #ccc; font-size: 12px;
            cursor: pointer;
        }
        .bp-item:hover { background: rgba(255,255,255,0.05); }
        .bp-item.selected { background: rgba(255,215,0,0.12); border-left: 3px solid gold; }
        .bp-item canvas {
            width: 24px; height: 24px;
            image-rendering: pixelated;
        }
        .bp-item .item-name { flex: 1; }
        .bp-item .item-count { color: #888; font-size: 11px; }

        /* Game canvas area */
        #game-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-top: 36px;
            background: #111;
            position: relative;
        }
        #game-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #2d5a1e;
        }

        /* Interaction prompt */
        #interact-prompt {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: gold;
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 150;
            display: none;
            border: 1px solid #5d4037;
        }

        /* Notification */
        .notif {
            position: fixed; top: 44px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); color: #fff; padding: 6px 14px;
            border-radius: 5px; font-size: 13px; z-index: 300;
            border-left: 3px solid gold;
            animation: notifIn 0.3s ease;
        }
        @keyframes notifIn { from { opacity: 0; transform: translateX(-50%) translateY(-8px); } }

        /* Mobile controls */
        #mobile-controls { display: none; position: fixed; z-index: 150; }
        .dpad {
            position: fixed; bottom: 20px; left: 20px;
            width: 120px; height: 120px;
        }
        .dpad-btn {
            position: absolute; width: 38px; height: 38px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            color: #fff; font-size: 16px; font-weight: bold;
        }
        .dpad-up { top: 0; left: 41px; }
        .dpad-down { bottom: 0; left: 41px; }
        .dpad-left { top: 41px; left: 0; }
        .dpad-right { top: 41px; right: 0; }
        .action-btn {
            position: fixed; width: 44px; height: 44px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            color: #fff; font-size: 13px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
        }
        #btn-a { bottom: 30px; right: 20px; background: rgba(76,175,80,0.3); border-color: rgba(76,175,80,0.5); }
        #btn-b { bottom: 80px; right: 60px; background: rgba(233,69,96,0.3); border-color: rgba(233,69,96,0.5); }
        #btn-bag {
            position: fixed; top: 44px; left: 6px;
            width: 32px; height: 32px;
            background: rgba(141,110,99,0.6);
            border: 2px solid #8d6e63;
            border-radius: 4px;
            color: #fff; font-size: 10px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            z-index: 160;
        }
        #btn-quest {
            position: fixed; top: 44px; right: 6px;
            width: 40px; height: 32px;
            background: rgba(55,71,79,0.6);
            border: 2px solid #546e7a;
            border-radius: 4px;
            color: #90caf9; font-size: 9px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            z-index: 160;
            display: none;
        }

        /* Missions panel */
        #missions {
            width: 200px;
            background: rgba(10, 15, 30, 0.92);
            border-left: 3px solid #37474f;
            padding-top: 40px;
            display: flex; flex-direction: column;
            z-index: 100;
            overflow-y: auto;
        }
        #missions-title {
            text-align: center; color: #90caf9;
            font-size: 14px; font-weight: bold;
            padding: 8px; letter-spacing: 1px;
            border-bottom: 2px solid #263238;
        }
        .mission {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .mission-header {
            display: flex; align-items: center; gap: 6px;
        }
        .mission-check {
            width: 14px; height: 14px;
            border: 2px solid #546e7a;
            border-radius: 3px;
            flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; color: #4caf50;
        }
        .mission.done .mission-check {
            border-color: #4caf50;
            background: rgba(76,175,80,0.15);
        }
        .mission-name {
            font-size: 12px; color: #cfd8dc;
            flex: 1;
        }
        .mission.done .mission-name {
            text-decoration: line-through;
            color: #607d8b;
        }
        .mission-desc {
            font-size: 10px; color: #78909c;
            margin-top: 3px; padding-left: 20px;
            line-height: 1.3;
        }
        .mission.done .mission-desc { color: #455a64; }
        .mission-reward {
            font-size: 10px; color: #ffd54f;
            padding-left: 20px; margin-top: 2px;
        }
        .mission.done .mission-reward { color: #5d4037; }

        /* Touch: toggle backpack, missions & controls */
        body.is-touch #backpack { display: none; position: fixed; left: 0; top: 0; bottom: 0; z-index: 180; }
        body.is-touch #backpack.open { display: flex; }
        body.is-touch #missions { display: none; position: fixed; right: 0; top: 0; bottom: 0; z-index: 180; }
        body.is-touch #missions.open { display: flex; }
        body.is-touch #mobile-controls { display: block; }
        body.is-touch #btn-bag { display: flex; }
        body.is-touch #btn-quest { display: flex; }
        body:not(.is-touch) #btn-bag { display: none; }
        body:not(.is-touch) #btn-quest { display: none; }

        /* Responsive */
        @media (max-width: 600px) {
            #backpack { width: 150px; }
            #missions { width: 170px; }
        }
    </style>
</head>
<body>

<!-- HUD -->
<div id="hud">
    <div id="hud-left">
        <span class="username" id="d-name"></span>
        <span class="coins" id="d-coins">Coins: 0</span>
        <div id="hud-hearts"></div>
    </div>
    <div id="hud-right">
        <a href="/games/01/home.html">Home</a>
        <a onclick="handleLogout()">Logout</a>
    </div>
</div>

<!-- Backpack -->
<div id="backpack">
    <div id="backpack-title">BACKPACK</div>
    <canvas id="elf-portrait" width="16" height="16"></canvas>
    <div id="bp-items"></div>
</div>

<!-- Game Canvas -->
<div id="game-area">
    <canvas id="game-canvas"></canvas>
</div>

<!-- Missions -->
<div id="missions">
    <div id="missions-title">MISSIONS</div>
    <div id="mission-list"></div>
</div>

<!-- Interaction Prompt -->
<div id="interact-prompt">Press <b>E</b> to interact</div>

<!-- Mobile Controls -->
<div id="mobile-controls">
    <div class="dpad">
        <div class="dpad-btn dpad-up" data-dir="up">&#9650;</div>
        <div class="dpad-btn dpad-down" data-dir="down">&#9660;</div>
        <div class="dpad-btn dpad-left" data-dir="left">&#9664;</div>
        <div class="dpad-btn dpad-right" data-dir="right">&#9654;</div>
    </div>
    <div class="action-btn" id="btn-a">A</div>
    <div class="action-btn" id="btn-b">B</div>
</div>
<div id="btn-bag">BAG</div>
<div id="btn-quest">QUEST</div>

<script>
// ============================================
// DEVICE DETECTION
// ============================================
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
if (isTouchDevice) document.body.classList.add('is-touch');

// ============================================
// AUTH
// ============================================
const API_URL = '/games/01/api';
let currentUser = null, authToken = null;

function checkAuth() {
    authToken = localStorage.getItem('game_token');
    const name = localStorage.getItem('game_username');
    if (authToken && name) {
        currentUser = name;
        document.getElementById('d-name').textContent = name;
        fetchCoins();
    } else {
        document.getElementById('d-name').textContent = 'Guest';
    }
}

async function fetchCoins() {
    try {
        const res = await fetch(`${API_URL}/user/profile`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (res.ok) {
            const data = await res.json();
            playerCoins = data.coins || 0;
            updateHUD();
        }
    } catch(e) {}
}

async function syncCoins() {
    if (!authToken) return;
    try {
        await fetch(`${API_URL}/user/coins`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${authToken}` },
            body: JSON.stringify({ coins: playerCoins })
        });
    } catch(e) {}
}

function handleLogout() {
    localStorage.removeItem('game_token');
    localStorage.removeItem('game_username');
    window.location.href = '/games/01/login.html';
}

// ============================================
// CONSTANTS
// ============================================
const TILE = 16;
const SCALE = 6;
const TS = TILE * SCALE; // 96px rendered tile
const MAP_W = 40;
const MAP_H = 30;
let activeMapW = MAP_W;
let activeMapH = MAP_H;

// Tile IDs
const T = {
    GRASS: 0,
    PATH: 1,
    TREE: 2,
    WATER: 3,
    WALL: 4,
    DOOR: 5,
    ROOF: 6,
    FLOWER: 7,
    ROCK: 8,
    CHEST: 9,
    BUSH: 10,
    BRIDGE: 11,
    // Interior tiles
    FLOOR: 12,
    IWALL: 13,
    TABLE: 14,
    CHAIR: 15,
    BED: 16,
    BOOKSHELF: 17,
    FIREPLACE: 18,
    RUG: 19,
    IDOOR: 20
};

const WALKABLE = new Set([T.GRASS, T.PATH, T.DOOR, T.FLOWER, T.BRIDGE, T.WATER, T.FLOOR, T.RUG, T.IDOOR]);

// ============================================
// MAP
// ============================================
function createMap() {
    const m = [];
    for (let y = 0; y < MAP_H; y++) {
        m[y] = [];
        for (let x = 0; x < MAP_W; x++) {
            m[y][x] = T.GRASS;
        }
    }

    // === Forest border (trees around the edges) ===
    for (let x = 0; x < MAP_W; x++) {
        for (let y = 0; y < 3; y++) m[y][x] = T.TREE;
        for (let y = MAP_H - 3; y < MAP_H; y++) m[y][x] = T.TREE;
    }
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < 3; x++) m[y][x] = T.TREE;
        for (let x = MAP_W - 3; x < MAP_W; x++) m[y][x] = T.TREE;
    }

    // === Paths ===
    // Main horizontal road
    for (let x = 3; x < MAP_W - 3; x++) { m[14][x] = T.PATH; m[15][x] = T.PATH; }
    // Main vertical road
    for (let y = 3; y < MAP_H - 3; y++) { m[y][19] = T.PATH; m[y][20] = T.PATH; }
    // Side path to east
    for (let x = 20; x < 32; x++) { m[9][x] = T.PATH; m[10][x] = T.PATH; }
    // Side path south
    for (let y = 15; y < 22; y++) { m[y][10] = T.PATH; m[y][11] = T.PATH; }

    // === Connecting paths to houses ===
    // Path north to House 1 (from main horizontal road)
    for (let y = 9; y <= 14; y++) { m[y][9] = T.PATH; }
    // Path west to House 2 (from main vertical road)
    for (let x = 19; x <= 23; x++) { m[7][x] = T.PATH; }
    // Path south to House 3 (already covered by south branch x=10-11)
    // Path south to House 4 (from east branch)
    for (let y = 10; y <= 12; y++) { m[y][30] = T.PATH; }

    // === House 1 (top-left village) ===
    buildHouse(m, 7, 5, 5, 4);

    // === House 2 (top-right) ===
    buildHouse(m, 24, 5, 5, 4);

    // === House 3 (bottom-left) ===
    buildHouse(m, 8, 18, 5, 4);

    // === House 4 (far east) ===
    buildHouse(m, 28, 12, 6, 4);

    // === River / Lake (east side) ===
    for (let y = 17; y < 25; y++) {
        for (let x = 25; x < 33; x++) {
            if (y >= 18 && y <= 23 && x >= 26 && x <= 31) {
                m[y][x] = T.WATER;
            }
        }
    }
    // Bridge over river
    m[20][26] = T.BRIDGE; m[20][27] = T.BRIDGE;

    // === Scattered trees ===
    const treePosns = [
        [5,12],[6,11],[13,5],[14,7],[15,6],[16,12],[17,11],[23,17],[24,18],
        [30,7],[31,8],[32,6],[14,22],[15,23],[33,15],[34,14],[35,16],
        [7,24],[8,25],[6,26],[12,26],[13,25],[36,10],[37,11],[36,22],
        [5,17],[4,18],[16,4],[17,3],[33,4],[34,5],[35,24],[36,25]
    ];
    for (const [x, y] of treePosns) {
        if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H && m[y][x] === T.GRASS) {
            m[y][x] = T.TREE;
        }
    }

    // === Flowers ===
    const flowerPosns = [
        [10,8],[11,7],[12,9],[18,7],[17,8],[22,11],[23,10],[15,17],
        [16,18],[6,15],[7,16],[30,20],[31,19],[13,12],[14,11],[25,8],
        [9,22],[10,23],[32,10],[18,24],[19,23],[21,16],[22,15]
    ];
    for (const [x, y] of flowerPosns) {
        if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H && m[y][x] === T.GRASS) {
            m[y][x] = T.FLOWER;
        }
    }

    // === Rocks ===
    const rockPosns = [
        [15,10],[16,9],[27,7],[28,8],[11,24],[35,18],[36,19],[4,10],[5,9]
    ];
    for (const [x, y] of rockPosns) {
        if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H && m[y][x] === T.GRASS) {
            m[y][x] = T.ROCK;
        }
    }

    // === Chests ===
    const chestPosns = [[12,7],[30,9],[9,21],[33,17],[18,4]];
    for (const [x, y] of chestPosns) {
        if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H) {
            m[y][x] = T.CHEST;
        }
    }

    // === Bushes ===
    const bushPosns = [
        [6,10],[7,9],[22,7],[23,8],[14,20],[15,21],[27,13],[34,13],
        [8,13],[17,6],[22,4],[29,9],[10,25],[34,21],[35,20]
    ];
    for (const [x, y] of bushPosns) {
        if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H && m[y][x] === T.GRASS) {
            m[y][x] = T.BUSH;
        }
    }

    return m;
}

function buildHouse(m, hx, hy, w, h) {
    // Roof row
    for (let x = hx; x < hx + w; x++) {
        if (x >= 0 && x < MAP_W && hy >= 0 && hy < MAP_H) m[hy][x] = T.ROOF;
    }
    // Walls
    for (let y = hy + 1; y < hy + h; y++) {
        for (let x = hx; x < hx + w; x++) {
            if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H) m[y][x] = T.WALL;
        }
    }
    // Door at bottom center
    const doorX = hx + Math.floor(w / 2);
    const doorY = hy + h - 1;
    if (doorX >= 0 && doorX < MAP_W && doorY >= 0 && doorY < MAP_H) m[doorY][doorX] = T.DOOR;
}

// ============================================
// HOUSE INTERIORS (10x8 maps)
// ============================================
// F=FLOOR, W=IWALL, T=TABLE, C=CHAIR, B=BED, K=BOOKSHELF, P=FIREPLACE, R=RUG, D=IDOOR
const INTERIOR_W = 10;
const INTERIOR_H = 8;

const HOUSE_INTERIORS = [
    // House 0: Village Cottage — cozy home with bed, table, fireplace
    {
        name: 'Village Cottage',
        map: [
            [13,13,13,13,13,13,13,13,13,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,16,16,12,14,14,12,18,12,13],
            [13,12,12,12,15,12,12,12,12,13],
            [13,12,19,19,19,19,12,12,12,13],
            [13,12,19,19,19,19,12,12,12,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,13,13,13,20,13,13,13,13,13]
        ],
        doorX: 4, doorY: 7  // IDOOR position inside
    },
    // House 1: Elder's Library — full of bookshelves and a reading table
    {
        name: "Elder's Library",
        map: [
            [13,13,13,13,13,13,13,13,13,13],
            [13,17,17,12,17,17,12,17,17,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,12,14,14,12,12,14,14,12,13],
            [13,12,15,12,19,19,12,15,12,13],
            [13,12,12,12,19,19,12,12,12,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,13,13,13,20,13,13,13,13,13]
        ],
        doorX: 4, doorY: 7
    },
    // House 2: Traveler's Inn — beds, a bar/table area
    {
        name: "Traveler's Inn",
        map: [
            [13,13,13,13,13,13,13,13,13,13],
            [13,16,16,12,12,12,16,16,12,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,12,12,14,14,14,12,12,12,13],
            [13,12,12,15,12,15,12,12,12,13],
            [13,12,19,19,19,19,19,12,18,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,13,13,13,20,13,13,13,13,13]
        ],
        doorX: 4, doorY: 7
    },
    // House 3: Blacksmith's Workshop — anvil(table), fireplace, tools(bookshelf)
    {
        name: "Blacksmith's Workshop",
        map: [
            [13,13,13,13,13,13,13,13,13,13],
            [13,18,12,12,17,12,12,12,18,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,12,14,14,12,14,14,12,12,13],
            [13,12,12,12,12,12,12,12,12,13],
            [13,12,12,19,19,19,12,12,12,13],
            [13,12,12,12,12,12,12,12,15,13],
            [13,13,13,13,13,20,13,13,13,13]
        ],
        doorX: 5, doorY: 7
    }
];

// Map house door positions (overworld) to interior index
const HOUSE_DOORS = [
    { doorX: 9, doorY: 8, interiorIdx: 0 },   // House 1 door
    { doorX: 26, doorY: 8, interiorIdx: 1 },  // House 2 door
    { doorX: 10, doorY: 21, interiorIdx: 2 }, // House 3 door
    { doorX: 31, doorY: 15, interiorIdx: 3 }  // House 4 door
];

// ============================================
// TILE RENDERING
// ============================================
const tileCanvases = {};
let animFrame = 0;

function mulberry32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        var t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function genTileSprite(tileId, variant) {
    const c = document.createElement('canvas');
    c.width = TILE; c.height = TILE;
    const ctx = c.getContext('2d');
    const rng = mulberry32(tileId * 1000 + (variant || 0));

    switch (tileId) {
        case T.GRASS: {
            const greens = ['#3a7d3e', '#357a38', '#4e8c51', '#2e6b30'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = greens[Math.floor(rng() * greens.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            break;
        }
        case T.PATH: {
            const tans = ['#c8a96e', '#b89a5e', '#d4b07a', '#a88b50'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = tans[Math.floor(rng() * tans.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // A few darker pebbles
            ctx.fillStyle = '#8d7748';
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(Math.floor(rng()*14)+1, Math.floor(rng()*14)+1, 1, 1);
            }
            break;
        }
        case T.TREE: {
            // Grass base
            const greens = ['#3a7d3e', '#357a38', '#2e6b30'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = greens[Math.floor(rng() * greens.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Variant controls tree shape
            const v = variant || 0;
            const trunkX = 7 + (v % 2);               // trunk shifts slightly
            const trunkW = v >= 3 ? 3 : 2;             // thick or thin trunk
            const trunkTop = v >= 3 ? 8 : 10;          // tall or short trunk
            const canopyR = [18, 22, 15, 28, 20][v];   // canopy radius squared
            const canopyCX = 8 + (v % 2 === 0 ? 0 : -1);
            const canopyCY = v >= 3 ? 4 : 6;           // tall trees: higher canopy
            const canopyTop = v >= 3 ? 0 : 2;
            const canopyBot = v >= 3 ? 9 : 11;
            const canopyL = v >= 3 ? 1 : 3;
            const canopyR2 = v >= 3 ? 15 : 13;
            // Trunk
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(trunkX, trunkTop, trunkW, 16 - trunkTop);
            ctx.fillStyle = '#4e342e';
            ctx.fillRect(trunkX, trunkTop + 2, 1, 16 - trunkTop - 2);
            // Bark detail
            ctx.fillStyle = '#6d5047';
            if (v % 2 === 0) ctx.fillRect(trunkX + trunkW - 1, trunkTop + 1, 1, 2);
            // Canopy
            const leafSets = [
                ['#1b5e20', '#2e7d32', '#256329', '#1a5218'],  // dark green
                ['#2e7d32', '#388e3c', '#1b5e20', '#33691e'],  // medium green
                ['#33691e', '#558b2f', '#2e7d32', '#1b5e20'],  // olive green
                ['#1b5e20', '#2e7d32', '#388e3c', '#4caf50'],  // bright tall
                ['#2e7d32', '#1b5e20', '#33691e', '#256329'],  // classic
            ];
            const leafColors = leafSets[v];
            for (let y = canopyTop; y < canopyBot; y++)
                for (let x = canopyL; x < canopyR2; x++) {
                    const dx = x - canopyCX, dy = y - canopyCY;
                    if (dx*dx + dy*dy < canopyR + rng()*5) {
                        ctx.fillStyle = leafColors[Math.floor(rng() * leafColors.length)];
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            // Highlight spots on canopy
            ctx.fillStyle = '#4caf50';
            for (let i = 0; i < 3; i++) {
                const hx = canopyL + Math.floor(rng() * (canopyR2 - canopyL));
                const hy = canopyTop + Math.floor(rng() * (canopyBot - canopyTop));
                ctx.fillRect(hx, hy, 1, 1);
            }
            break;
        }
        case T.WATER: {
            const blues = ['#1565c0', '#1976d2', '#1e88e5', '#0d47a1'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    const idx = (x + y + (variant || 0)) % blues.length;
                    ctx.fillStyle = blues[idx];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Wave highlights
            ctx.fillStyle = '#42a5f5';
            const waveOff = (variant || 0) % 4;
            for (let x = waveOff; x < TILE; x += 4) {
                ctx.fillRect(x, 4, 2, 1);
                ctx.fillRect((x+2) % TILE, 10, 2, 1);
            }
            break;
        }
        case T.WALL: {
            // Brick pattern
            ctx.fillStyle = '#795548';
            ctx.fillRect(0, 0, TILE, TILE);
            ctx.fillStyle = '#5d4037';
            for (let y = 0; y < TILE; y += 4) {
                ctx.fillRect(0, y+3, TILE, 1);
                const off = (y % 8 === 0) ? 0 : 4;
                for (let x = off; x < TILE; x += 8) {
                    ctx.fillRect(x, y, 1, 3);
                }
            }
            break;
        }
        case T.DOOR: {
            // Wall behind
            ctx.fillStyle = '#795548';
            ctx.fillRect(0, 0, TILE, TILE);
            // Door
            ctx.fillStyle = '#3e2723';
            ctx.fillRect(3, 2, 10, 14);
            ctx.fillStyle = '#4e342e';
            ctx.fillRect(4, 3, 8, 12);
            // Handle
            ctx.fillStyle = '#ffd54f';
            ctx.fillRect(10, 9, 1, 1);
            break;
        }
        case T.ROOF: {
            // Red roof tiles
            const reds = ['#b71c1c', '#c62828', '#d32f2f', '#a31515'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = reds[Math.floor(rng() * reds.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Ridge line
            ctx.fillStyle = '#7f0000';
            ctx.fillRect(0, 7, TILE, 1);
            break;
        }
        case T.FLOWER: {
            // Grass base
            const greens = ['#3a7d3e', '#357a38', '#2e6b30'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = greens[Math.floor(rng() * greens.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Flowers
            const petalColors = ['#e91e63', '#ffeb3b', '#ff9800', '#9c27b0', '#fff'];
            for (let i = 0; i < 3; i++) {
                const fx = Math.floor(rng() * 12) + 2;
                const fy = Math.floor(rng() * 12) + 2;
                ctx.fillStyle = petalColors[Math.floor(rng() * petalColors.length)];
                ctx.fillRect(fx, fy, 1, 1);
                ctx.fillRect(fx+1, fy, 1, 1);
                ctx.fillRect(fx, fy+1, 1, 1);
                ctx.fillRect(fx+1, fy+1, 1, 1);
                ctx.fillStyle = '#ffeb3b';
                ctx.fillRect(fx, fy, 1, 1);
            }
            break;
        }
        case T.ROCK: {
            // Grass base
            const greens = ['#3a7d3e', '#357a38'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = greens[Math.floor(rng() * greens.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Rock
            const greys = ['#9e9e9e', '#757575', '#bdbdbd', '#616161'];
            for (let y = 4; y < 14; y++)
                for (let x = 3; x < 13; x++) {
                    const dx = x - 8, dy = y - 9;
                    if (dx*dx*0.8 + dy*dy < 18) {
                        ctx.fillStyle = greys[Math.floor(rng() * greys.length)];
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            break;
        }
        case T.CHEST: {
            // Grass base
            const greens = ['#3a7d3e', '#357a38', '#2e6b30'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = greens[Math.floor(rng() * greens.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Chest box
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(4, 7, 8, 6);
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(4, 7, 8, 1);
            ctx.fillRect(4, 12, 8, 1);
            // Lock
            ctx.fillStyle = '#ffd54f';
            ctx.fillRect(7, 9, 2, 2);
            break;
        }
        case T.BUSH: {
            // Grass base
            const greens = ['#3a7d3e', '#357a38', '#2e6b30'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = greens[Math.floor(rng() * greens.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Bush
            const bushColors = ['#2e7d32', '#388e3c', '#1b5e20', '#4caf50'];
            for (let y = 5; y < 14; y++)
                for (let x = 3; x < 13; x++) {
                    const dx = x - 8, dy = y - 9;
                    if (dx*dx + dy*dy < 22) {
                        ctx.fillStyle = bushColors[Math.floor(rng() * bushColors.length)];
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            break;
        }
        case T.BRIDGE: {
            // Water underneath
            ctx.fillStyle = '#1565c0';
            ctx.fillRect(0, 0, TILE, TILE);
            // Planks
            ctx.fillStyle = '#8d6e63';
            for (let x = 0; x < TILE; x += 4) {
                ctx.fillRect(x, 1, 3, 14);
            }
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(0, 0, TILE, 1);
            ctx.fillRect(0, 15, TILE, 1);
            break;
        }
        case T.FLOOR: {
            const woods = ['#c8a882', '#c2a27a', '#cbb08a', '#bfa076'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = woods[Math.floor(rng() * woods.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            // Plank lines
            ctx.fillStyle = '#a88960';
            for (let y = 0; y < TILE; y += 4) {
                ctx.fillRect(0, y, TILE, 1);
            }
            break;
        }
        case T.IWALL: {
            // Stone interior wall
            ctx.fillStyle = '#9e9e9e';
            ctx.fillRect(0, 0, TILE, TILE);
            ctx.fillStyle = '#757575';
            for (let y = 0; y < TILE; y += 4) {
                ctx.fillRect(0, y + 3, TILE, 1);
                const off = (y % 8 === 0) ? 0 : 5;
                for (let x = off; x < TILE; x += 10) {
                    ctx.fillRect(x, y, 1, 3);
                }
            }
            // Highlight
            ctx.fillStyle = '#bdbdbd';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(Math.floor(rng()*14)+1, Math.floor(rng()*14)+1, 1, 1);
            }
            break;
        }
        case T.TABLE: {
            // Floor base
            const woods = ['#c8a882', '#c2a27a'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = woods[Math.floor(rng() * woods.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            ctx.fillStyle = '#a88960';
            for (let y = 0; y < TILE; y += 4) ctx.fillRect(0, y, TILE, 1);
            // Table top
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(2, 3, 12, 6);
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(2, 3, 12, 1);
            ctx.fillRect(2, 8, 12, 1);
            // Legs
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(3, 9, 1, 4);
            ctx.fillRect(12, 9, 1, 4);
            break;
        }
        case T.CHAIR: {
            // Floor base
            const woods = ['#c8a882', '#c2a27a'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = woods[Math.floor(rng() * woods.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            ctx.fillStyle = '#a88960';
            for (let y = 0; y < TILE; y += 4) ctx.fillRect(0, y, TILE, 1);
            // Chair back
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(5, 2, 6, 2);
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(5, 2, 1, 9);
            ctx.fillRect(10, 2, 1, 9);
            // Seat
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(5, 7, 6, 3);
            // Legs
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(5, 11, 1, 3);
            ctx.fillRect(10, 11, 1, 3);
            break;
        }
        case T.BED: {
            // Floor base
            const woods = ['#c8a882', '#c2a27a'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = woods[Math.floor(rng() * woods.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            ctx.fillStyle = '#a88960';
            for (let y = 0; y < TILE; y += 4) ctx.fillRect(0, y, TILE, 1);
            // Bed frame
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(2, 2, 12, 12);
            // Pillow
            ctx.fillStyle = '#fff';
            ctx.fillRect(3, 3, 10, 3);
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(3, 5, 10, 1);
            // Blanket
            ctx.fillStyle = '#1565c0';
            ctx.fillRect(3, 6, 10, 7);
            ctx.fillStyle = '#1976d2';
            ctx.fillRect(4, 7, 8, 5);
            break;
        }
        case T.BOOKSHELF: {
            // Wall base
            ctx.fillStyle = '#9e9e9e';
            ctx.fillRect(0, 0, TILE, TILE);
            // Shelf frame
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(1, 1, 14, 14);
            // Shelves
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(1, 5, 14, 1);
            ctx.fillRect(1, 10, 14, 1);
            // Books (top shelf)
            const bookColors = ['#c62828', '#1565c0', '#2e7d32', '#f9a825', '#6a1b9a', '#e65100'];
            for (let bx = 2; bx < 14; bx += 2) {
                ctx.fillStyle = bookColors[Math.floor(rng() * bookColors.length)];
                ctx.fillRect(bx, 2, 2, 3);
                ctx.fillStyle = '#fff';
                ctx.fillRect(bx, 3, 2, 1);
            }
            // Books (middle shelf)
            for (let bx = 2; bx < 14; bx += 2) {
                ctx.fillStyle = bookColors[Math.floor(rng() * bookColors.length)];
                ctx.fillRect(bx, 6, 2, 4);
                ctx.fillStyle = '#fff';
                ctx.fillRect(bx, 8, 2, 1);
            }
            // Books (bottom shelf)
            for (let bx = 2; bx < 14; bx += 2) {
                ctx.fillStyle = bookColors[Math.floor(rng() * bookColors.length)];
                ctx.fillRect(bx, 11, 2, 3);
            }
            break;
        }
        case T.FIREPLACE: {
            // Wall base
            ctx.fillStyle = '#9e9e9e';
            ctx.fillRect(0, 0, TILE, TILE);
            // Stone frame
            ctx.fillStyle = '#616161';
            ctx.fillRect(2, 2, 12, 12);
            ctx.fillStyle = '#757575';
            ctx.fillRect(1, 2, 1, 12);
            ctx.fillRect(14, 2, 1, 12);
            ctx.fillRect(1, 1, 14, 1);
            // Fire opening
            ctx.fillStyle = '#212121';
            ctx.fillRect(4, 5, 8, 9);
            // Fire
            ctx.fillStyle = '#ff6f00';
            ctx.fillRect(5, 9, 6, 4);
            ctx.fillStyle = '#ffab00';
            ctx.fillRect(6, 7, 4, 5);
            ctx.fillStyle = '#ffd600';
            ctx.fillRect(7, 8, 2, 3);
            // Embers
            ctx.fillStyle = '#dd2c00';
            ctx.fillRect(5, 13, 6, 1);
            break;
        }
        case T.RUG: {
            // Floor base
            const woods = ['#c8a882', '#c2a27a'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = woods[Math.floor(rng() * woods.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            ctx.fillStyle = '#a88960';
            for (let y = 0; y < TILE; y += 4) ctx.fillRect(0, y, TILE, 1);
            // Rug
            ctx.fillStyle = '#b71c1c';
            ctx.fillRect(1, 1, 14, 14);
            ctx.fillStyle = '#d32f2f';
            ctx.fillRect(2, 2, 12, 12);
            // Pattern
            ctx.fillStyle = '#ffd54f';
            ctx.fillRect(3, 3, 10, 1);
            ctx.fillRect(3, 12, 10, 1);
            ctx.fillRect(3, 3, 1, 10);
            ctx.fillRect(12, 3, 1, 10);
            // Center diamond
            ctx.fillStyle = '#ff8f00';
            ctx.fillRect(7, 5, 2, 6);
            ctx.fillRect(6, 6, 4, 4);
            break;
        }
        case T.IDOOR: {
            // Floor base
            const woods = ['#c8a882', '#c2a27a'];
            for (let y = 0; y < TILE; y++)
                for (let x = 0; x < TILE; x++) {
                    ctx.fillStyle = woods[Math.floor(rng() * woods.length)];
                    ctx.fillRect(x, y, 1, 1);
                }
            ctx.fillStyle = '#a88960';
            for (let y = 0; y < TILE; y += 4) ctx.fillRect(0, y, TILE, 1);
            // Door mat
            ctx.fillStyle = '#795548';
            ctx.fillRect(3, 10, 10, 4);
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(4, 11, 8, 2);
            // Arrow indicating exit
            ctx.fillStyle = '#ffd54f';
            ctx.fillRect(7, 12, 2, 1);
            ctx.fillRect(6, 11, 4, 1);
            ctx.fillRect(7, 13, 2, 1);
            break;
        }
    }
    return c;
}

function getTileCanvas(tileId, variant) {
    const key = `${tileId}_${variant || 0}`;
    if (!tileCanvases[key]) tileCanvases[key] = genTileSprite(tileId, variant);
    return tileCanvases[key];
}

// ============================================
// ELF SPRITE
// ============================================
const elfSprites = {};

function genElfSprite(dir, frame, hasSword) {
    const c = document.createElement('canvas');
    c.width = TILE; c.height = TILE;
    const ctx = c.getContext('2d');

    const skin = '#fdd9b5';
    const skinShade = '#e8c8a0';
    const hair = '#8d6e63';
    const tunic = '#2e7d32';
    const tunicDark = '#1b5e20';
    const tunicLight = '#43a047';
    const boots = '#5d4037';
    const bootsDark = '#3e2723';
    const belt = '#8d6e63';
    const beltBuckle = '#ffd600';
    const hat = '#76ff03';
    const hatDark = '#64dd17';
    const hatBand = '#33691e';
    const eyeWhite = '#fff';
    const eyeColor = '#1a237e';
    const mouth = '#c97a5a';
    const swordBlade = '#b0bec5';
    const swordHilt = '#8d6e63';
    const swordGuard = '#ffd600';

    if (dir === 'down') {
        // Hat
        ctx.fillStyle = hat;
        ctx.fillRect(4, 0, 8, 2);
        ctx.fillStyle = hatDark;
        ctx.fillRect(5, 0, 6, 1);
        ctx.fillStyle = hatBand;
        ctx.fillRect(5, 2, 6, 1);
        // Hair under hat
        ctx.fillStyle = hair;
        ctx.fillRect(5, 2, 6, 2);
        // Face
        ctx.fillStyle = skin;
        ctx.fillRect(5, 3, 6, 4);
        ctx.fillStyle = skinShade;
        ctx.fillRect(5, 6, 6, 1);
        // Eyes
        ctx.fillStyle = eyeWhite;
        ctx.fillRect(6, 4, 2, 1);
        ctx.fillRect(9, 4, 2, 1);
        ctx.fillStyle = eyeColor;
        ctx.fillRect(7, 4, 1, 1);
        ctx.fillRect(9, 4, 1, 1);
        // Eyebrows
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(6, 3, 2, 1);
        ctx.fillRect(9, 3, 2, 1);
        // Nose
        ctx.fillStyle = skinShade;
        ctx.fillRect(8, 5, 1, 1);
        // Mouth
        ctx.fillStyle = mouth;
        ctx.fillRect(7, 6, 2, 1);
        // Ears (pointed)
        ctx.fillStyle = skin;
        ctx.fillRect(4, 3, 1, 2);
        ctx.fillRect(11, 3, 1, 2);
        ctx.fillRect(3, 3, 1, 1);
        ctx.fillRect(12, 3, 1, 1);
        // Arms (skin colored, on sides of tunic)
        ctx.fillStyle = tunic;
        ctx.fillRect(3, 7, 2, 3);   // left arm sleeve
        ctx.fillRect(11, 7, 2, 3);  // right arm sleeve
        ctx.fillStyle = skin;
        ctx.fillRect(3, 10, 2, 1);  // left hand
        ctx.fillRect(11, 10, 2, 1); // right hand
        // Sword in right hand
        if (hasSword) {
            ctx.fillStyle = swordHilt;
            ctx.fillRect(12, 9, 1, 2);
            ctx.fillStyle = swordGuard;
            ctx.fillRect(11, 9, 3, 1);
            ctx.fillStyle = swordBlade;
            ctx.fillRect(12, 11, 1, 4);
            ctx.fillStyle = '#cfd8dc';
            ctx.fillRect(12, 11, 1, 1);
        }
        // Tunic
        ctx.fillStyle = tunic;
        ctx.fillRect(5, 7, 6, 4);
        ctx.fillStyle = tunicDark;
        ctx.fillRect(5, 7, 1, 4);
        ctx.fillRect(10, 7, 1, 4);
        ctx.fillStyle = tunicLight;
        ctx.fillRect(6, 7, 4, 1);
        ctx.fillStyle = tunicDark;
        ctx.fillRect(8, 8, 1, 2);
        // Belt
        ctx.fillStyle = belt;
        ctx.fillRect(5, 10, 6, 1);
        ctx.fillStyle = beltBuckle;
        ctx.fillRect(8, 10, 1, 1);
        // Legs/boots
        ctx.fillStyle = boots;
        const legOff = frame === 1 ? 1 : 0;
        ctx.fillRect(6 - legOff, 11, 2, 3);
        ctx.fillRect(8 + legOff, 11, 2, 3);
        ctx.fillStyle = bootsDark;
        ctx.fillRect(6 - legOff, 13, 2, 1);
        ctx.fillRect(8 + legOff, 13, 2, 1);
        ctx.fillStyle = '#795548';
        ctx.fillRect(6 - legOff, 12, 1, 1);
        ctx.fillRect(8 + legOff, 12, 1, 1);
    } else if (dir === 'up') {
        // Hat (back)
        ctx.fillStyle = hat;
        ctx.fillRect(4, 0, 8, 2);
        ctx.fillStyle = hatDark;
        ctx.fillRect(5, 0, 6, 2);
        ctx.fillStyle = hatBand;
        ctx.fillRect(5, 2, 6, 1);
        // Hair (back)
        ctx.fillStyle = hair;
        ctx.fillRect(5, 2, 6, 4);
        // Ears
        ctx.fillStyle = skin;
        ctx.fillRect(4, 3, 1, 2);
        ctx.fillRect(11, 3, 1, 2);
        ctx.fillRect(3, 3, 1, 1);
        ctx.fillRect(12, 3, 1, 1);
        // Arms
        ctx.fillStyle = tunicDark;
        ctx.fillRect(3, 7, 2, 3);
        ctx.fillRect(11, 7, 2, 3);
        ctx.fillStyle = skin;
        ctx.fillRect(3, 10, 2, 1);
        ctx.fillRect(11, 10, 2, 1);
        // Sword in right hand (behind, blade goes up)
        if (hasSword) {
            ctx.fillStyle = swordBlade;
            ctx.fillRect(12, 4, 1, 5);
            ctx.fillStyle = swordGuard;
            ctx.fillRect(11, 9, 3, 1);
        }
        // Tunic back
        ctx.fillStyle = tunicDark;
        ctx.fillRect(5, 6, 6, 5);
        ctx.fillStyle = tunic;
        ctx.fillRect(6, 6, 4, 4);
        ctx.fillStyle = belt;
        ctx.fillRect(5, 10, 6, 1);
        ctx.fillStyle = beltBuckle;
        ctx.fillRect(8, 10, 1, 1);
        // Legs
        ctx.fillStyle = boots;
        const legOff = frame === 1 ? 1 : 0;
        ctx.fillRect(6 - legOff, 11, 2, 3);
        ctx.fillRect(8 + legOff, 11, 2, 3);
        ctx.fillStyle = bootsDark;
        ctx.fillRect(6 - legOff, 13, 2, 1);
        ctx.fillRect(8 + legOff, 13, 2, 1);
    } else if (dir === 'left') {
        // Hat (side)
        ctx.fillStyle = hat;
        ctx.fillRect(4, 0, 6, 2);
        ctx.fillStyle = hatBand;
        ctx.fillRect(5, 2, 5, 1);
        // Hair side
        ctx.fillStyle = hair;
        ctx.fillRect(6, 2, 5, 2);
        // Face
        ctx.fillStyle = skin;
        ctx.fillRect(5, 3, 4, 4);
        ctx.fillStyle = skinShade;
        ctx.fillRect(5, 6, 4, 1);
        // Eye
        ctx.fillStyle = eyeWhite;
        ctx.fillRect(5, 4, 2, 1);
        ctx.fillStyle = eyeColor;
        ctx.fillRect(5, 4, 1, 1);
        // Eyebrow
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(5, 3, 2, 1);
        // Nose
        ctx.fillStyle = skinShade;
        ctx.fillRect(4, 5, 1, 1);
        // Mouth
        ctx.fillStyle = mouth;
        ctx.fillRect(5, 6, 1, 1);
        // Ear (pointed left)
        ctx.fillStyle = skin;
        ctx.fillRect(4, 3, 1, 2);
        ctx.fillRect(3, 3, 1, 1);
        // Back arm (right arm, behind body)
        ctx.fillStyle = tunicDark;
        ctx.fillRect(9, 7, 2, 3);
        ctx.fillStyle = skinShade;
        ctx.fillRect(9, 10, 2, 1);
        // Sword (behind, blade points left)
        if (hasSword) {
            ctx.fillStyle = swordBlade;
            ctx.fillRect(2, 9, 4, 1);
            ctx.fillStyle = '#cfd8dc';
            ctx.fillRect(2, 9, 1, 1);
            ctx.fillStyle = swordGuard;
            ctx.fillRect(5, 8, 1, 3);
            ctx.fillStyle = swordHilt;
            ctx.fillRect(6, 9, 1, 1);
        }
        // Front arm (left arm)
        ctx.fillStyle = tunic;
        ctx.fillRect(4, 7, 2, 3);
        ctx.fillStyle = skin;
        ctx.fillRect(4, 10, 2, 1);
        // Tunic
        ctx.fillStyle = tunic;
        ctx.fillRect(5, 7, 5, 3);
        ctx.fillStyle = tunicDark;
        ctx.fillRect(5, 7, 1, 3);
        ctx.fillStyle = tunicLight;
        ctx.fillRect(6, 7, 3, 1);
        ctx.fillStyle = belt;
        ctx.fillRect(5, 10, 5, 1);
        ctx.fillStyle = beltBuckle;
        ctx.fillRect(6, 10, 1, 1);
        // Legs
        ctx.fillStyle = boots;
        const legOff = frame === 1 ? 1 : 0;
        ctx.fillRect(6, 11 - legOff, 2, 3);
        ctx.fillRect(8, 11 + legOff, 2, 3);
        ctx.fillStyle = bootsDark;
        ctx.fillRect(6, 13 - legOff, 2, 1);
        ctx.fillRect(8, 13 + legOff, 2, 1);
    } else { // right
        // Hat (side)
        ctx.fillStyle = hat;
        ctx.fillRect(6, 0, 6, 2);
        ctx.fillStyle = hatBand;
        ctx.fillRect(6, 2, 5, 1);
        // Hair
        ctx.fillStyle = hair;
        ctx.fillRect(5, 2, 5, 2);
        // Face
        ctx.fillStyle = skin;
        ctx.fillRect(7, 3, 4, 4);
        ctx.fillStyle = skinShade;
        ctx.fillRect(7, 6, 4, 1);
        // Eye
        ctx.fillStyle = eyeWhite;
        ctx.fillRect(9, 4, 2, 1);
        ctx.fillStyle = eyeColor;
        ctx.fillRect(10, 4, 1, 1);
        // Eyebrow
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(9, 3, 2, 1);
        // Nose
        ctx.fillStyle = skinShade;
        ctx.fillRect(11, 5, 1, 1);
        // Mouth
        ctx.fillStyle = mouth;
        ctx.fillRect(10, 6, 1, 1);
        // Ear (pointed right)
        ctx.fillStyle = skin;
        ctx.fillRect(11, 3, 1, 2);
        ctx.fillRect(12, 3, 1, 1);
        // Back arm (left arm, behind body)
        ctx.fillStyle = tunicDark;
        ctx.fillRect(5, 7, 2, 3);
        ctx.fillStyle = skinShade;
        ctx.fillRect(5, 10, 2, 1);
        // Front arm (right arm) + sword
        ctx.fillStyle = tunic;
        ctx.fillRect(10, 7, 2, 3);
        ctx.fillStyle = skin;
        ctx.fillRect(10, 10, 2, 1);
        // Sword (blade points right)
        if (hasSword) {
            ctx.fillStyle = swordHilt;
            ctx.fillRect(10, 9, 1, 1);
            ctx.fillStyle = swordGuard;
            ctx.fillRect(10, 8, 1, 3);
            ctx.fillStyle = swordBlade;
            ctx.fillRect(11, 9, 4, 1);
            ctx.fillStyle = '#cfd8dc';
            ctx.fillRect(14, 9, 1, 1);
        }
        // Tunic
        ctx.fillStyle = tunic;
        ctx.fillRect(6, 7, 5, 3);
        ctx.fillStyle = tunicDark;
        ctx.fillRect(10, 7, 1, 3);
        ctx.fillStyle = tunicLight;
        ctx.fillRect(7, 7, 3, 1);
        ctx.fillStyle = belt;
        ctx.fillRect(6, 10, 5, 1);
        ctx.fillStyle = beltBuckle;
        ctx.fillRect(9, 10, 1, 1);
        // Legs
        ctx.fillStyle = boots;
        const legOff = frame === 1 ? 1 : 0;
        ctx.fillRect(6, 11 + legOff, 2, 3);
        ctx.fillRect(8, 11 - legOff, 2, 3);
        ctx.fillStyle = bootsDark;
        ctx.fillRect(6, 13 + legOff, 2, 1);
        ctx.fillRect(8, 13 - legOff, 2, 1);
    }

    return c;
}

const elfSwordSprites = {};

function initElfSprites() {
    for (const dir of ['up', 'down', 'left', 'right']) {
        elfSprites[dir] = [genElfSprite(dir, 0, false), genElfSprite(dir, 1, false)];
        elfSwordSprites[dir] = [genElfSprite(dir, 0, true), genElfSprite(dir, 1, true)];
    }
}

// ============================================
// ITEMS
// ============================================
const ITEM_DEFS = {
    sword:  { name: 'Sword',  color: '#b0bec5', desc: 'A trusty blade' },
    shield: { name: 'Shield', color: '#5c6bc0', desc: 'Block attacks' },
    key:    { name: 'Key',    color: '#ffd54f', desc: 'Opens locks' },
    potion: { name: 'Potion', color: '#e91e63', desc: 'Restores 1 heart' },
    coins:  { name: 'Coins',  color: '#ffc107', desc: 'Currency' }
};

function genItemIcon(itemId) {
    const c = document.createElement('canvas');
    c.width = 16; c.height = 16;
    const ctx = c.getContext('2d');

    if (itemId === 'sword') {
        ctx.fillStyle = '#78909c';
        ctx.fillRect(7, 1, 2, 9);
        ctx.fillStyle = '#b0bec5';
        ctx.fillRect(7, 1, 2, 2);
        ctx.fillStyle = '#8d6e63';
        ctx.fillRect(5, 10, 6, 1);
        ctx.fillStyle = '#6d4c41';
        ctx.fillRect(7, 11, 2, 3);
    } else if (itemId === 'shield') {
        ctx.fillStyle = '#3949ab';
        ctx.fillRect(4, 2, 8, 10);
        ctx.fillStyle = '#5c6bc0';
        ctx.fillRect(5, 3, 6, 8);
        ctx.fillStyle = '#ffd54f';
        ctx.fillRect(7, 5, 2, 4);
        ctx.fillRect(6, 6, 4, 2);
        ctx.fillStyle = '#3949ab';
        ctx.fillRect(4, 12, 8, 1);
        ctx.fillRect(5, 13, 6, 1);
        ctx.fillRect(6, 14, 4, 1);
    } else if (itemId === 'key') {
        ctx.fillStyle = '#ffd54f';
        ctx.fillRect(6, 2, 4, 4);
        ctx.fillRect(7, 3, 2, 2);
        ctx.fillStyle = '#ffc107';
        ctx.fillRect(7, 6, 2, 7);
        ctx.fillRect(9, 10, 2, 1);
        ctx.fillRect(9, 12, 2, 1);
        // Hollow ring
        ctx.clearRect(7, 3, 2, 2);
    } else if (itemId === 'potion') {
        ctx.fillStyle = '#6d4c41';
        ctx.fillRect(7, 1, 2, 2);
        ctx.fillStyle = '#e91e63';
        ctx.fillRect(5, 4, 6, 8);
        ctx.fillStyle = '#f06292';
        ctx.fillRect(6, 5, 2, 3);
        ctx.fillStyle = '#e91e63';
        ctx.fillRect(5, 12, 6, 2);
        ctx.fillRect(6, 14, 4, 1);
    } else if (itemId === 'coins') {
        ctx.fillStyle = '#ffc107';
        ctx.fillRect(5, 4, 6, 8);
        ctx.fillStyle = '#ffb300';
        ctx.fillRect(4, 5, 1, 6);
        ctx.fillRect(11, 5, 1, 6);
        ctx.fillStyle = '#ffd54f';
        ctx.fillRect(6, 5, 2, 2);
        ctx.fillStyle = '#ff8f00';
        ctx.fillRect(7, 7, 2, 3);
    }
    return c;
}

// ============================================
// GAME STATE
// ============================================
let gameMap = null;
let openedChests = new Set(); // "x,y" keys
let cutBushes = new Set();
// 4 key bushes — one near each house, these sparkle as a hint
const KEY_BUSHES = new Set(['7,9', '23,8', '14,20', '27,13']);

// Player
let player = { x: 19, y: 13, dir: 'down', frame: 0 };
let playerHP = 3;
let maxHP = 3;
let playerCoins = 0;
let inventory = { sword: 1, shield: 0, key: 0, potion: 0, coins: 0 };
let selectedItem = 'sword';

// Movement interpolation
let isMoving = false;
let moveFrom = { x: 0, y: 0 };
let moveTo = { x: 0, y: 0 };
let moveProgress = 0;
const MOVE_SPEED = 5; // tiles per second

// Sword swing
let swinging = false;
let swingTimer = 0;

// Interior state
let insideHouse = false;
let currentInterior = -1; // index into HOUSE_INTERIORS
let overworldMap = null;  // store overworld map when inside
let overworldPos = { x: 0, y: 0, dir: 'down' }; // player pos before entering
let housesVisited = new Set(); // track which houses player has entered

// Star Wars iris wipe transition
let transitioning = false;
let transitionPhase = 'none'; // 'iris_close', 'iris_open', 'none'
let transitionProgress = 0;
const TRANSITION_SPEED = 1.8; // full transition per second
let transitionCallback = null;

// Canvas
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

// ============================================
// CAMERA & RENDERING
// ============================================
function resizeCanvas() {
    const area = document.getElementById('game-area');
    const maxW = area.clientWidth;
    const maxH = area.clientHeight;
    // How many tiles fit
    const tilesX = Math.floor(maxW / TS);
    const tilesY = Math.floor(maxH / TS);
    const viewW = Math.max(10, Math.min(tilesX, activeMapW));
    const viewH = Math.max(8, Math.min(tilesY, activeMapH));
    canvas.width = viewW * TS;
    canvas.height = viewH * TS;
    canvas.tilesX = viewW;
    canvas.tilesY = viewH;
}

function getCameraOffset() {
    let px = player.x, py = player.y;
    if (isMoving) {
        px = moveFrom.x + (moveTo.x - moveFrom.x) * moveProgress;
        py = moveFrom.y + (moveTo.y - moveFrom.y) * moveProgress;
    }
    const halfX = Math.floor(canvas.tilesX / 2);
    const halfY = Math.floor(canvas.tilesY / 2);
    let camX = px - halfX;
    let camY = py - halfY;
    camX = Math.max(0, Math.min(activeMapW - canvas.tilesX, camX));
    camY = Math.max(0, Math.min(activeMapH - canvas.tilesY, camY));
    return { x: camX, y: camY };
}

function render() {
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const cam = getCameraOffset();
    const waterVariant = Math.floor(animFrame / 30) % 4;

    // Draw tiles
    for (let sy = 0; sy < canvas.tilesY; sy++) {
        for (let sx = 0; sx < canvas.tilesX; sx++) {
            const mx = Math.floor(cam.x) + sx;
            const my = Math.floor(cam.y) + sy;
            if (mx < 0 || mx >= activeMapW || my < 0 || my >= activeMapH) continue;

            let tileId = gameMap[my][mx];
            const key = `${mx},${my}`;

            // Opened chests become grass
            if (tileId === T.CHEST && openedChests.has(key)) tileId = T.GRASS;
            // Cut bushes become grass
            if (tileId === T.BUSH && cutBushes.has(key)) tileId = T.GRASS;

            // Trees get unique variant per position, water animates
            let variant = 0;
            if (tileId === T.WATER) variant = waterVariant;
            else if (tileId === T.TREE) variant = ((mx * 7 + my * 13) % 5);
            const tileC = getTileCanvas(tileId, variant);
            const dx = sx * TS - (cam.x % 1) * TS;
            const dy = sy * TS - (cam.y % 1) * TS;
            ctx.drawImage(tileC, dx, dy, TS, TS);
        }
    }

    // Draw sparkles on key bushes (hint that they hide a key)
    if (!insideHouse) for (const kb of KEY_BUSHES) {
        if (cutBushes.has(kb)) continue; // already cut
        const [bx, by] = kb.split(',').map(Number);
        const sx2 = bx - Math.floor(cam.x);
        const sy2 = by - Math.floor(cam.y);
        if (sx2 < -1 || sx2 > canvas.tilesX || sy2 < -1 || sy2 > canvas.tilesY) continue;
        const dx = sx2 * TS - (cam.x % 1) * TS;
        const dy = sy2 * TS - (cam.y % 1) * TS;
        // 3 sparkle points that twinkle at different phases
        const t = performance.now() / 1000;
        const sparkles = [
            { ox: 0.2, oy: 0.15, phase: 0 },
            { ox: 0.7, oy: 0.3, phase: 2.1 },
            { ox: 0.45, oy: 0.65, phase: 4.2 },
        ];
        for (const sp of sparkles) {
            const brightness = Math.sin(t * 3 + sp.phase) * 0.5 + 0.5;
            if (brightness < 0.3) continue; // dim sparkle hidden
            const size = 2 + brightness * 4;
            const alpha = brightness * 0.9;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#fffbe0';
            // Draw a small cross/star shape
            const cx = dx + sp.ox * TS;
            const cy = dy + sp.oy * TS;
            ctx.fillRect(cx - size/2, cy - 1, size, 2);
            ctx.fillRect(cx - 1, cy - size/2, 2, size);
            ctx.restore();
        }
    }

    // Draw elf
    let elfX = player.x, elfY = player.y;
    if (isMoving) {
        elfX = moveFrom.x + (moveTo.x - moveFrom.x) * moveProgress;
        elfY = moveFrom.y + (moveTo.y - moveFrom.y) * moveProgress;
    }
    const drawFrame = isMoving ? (Math.floor(animFrame / 8) % 2) : 0;
    const hasSword = inventory.sword > 0;
    const spriteSet = hasSword ? elfSwordSprites : elfSprites;
    const elfC = spriteSet[player.dir][drawFrame];
    const ex = (elfX - cam.x) * TS;
    const ey = (elfY - cam.y) * TS;

    // Check if elf is swimming
    const elfTileX = Math.round(elfX), elfTileY = Math.round(elfY);
    const isSwimming = gameMap[elfTileY] && gameMap[elfTileY][elfTileX] === T.WATER;

    if (isSwimming) {
        // Draw only top 60% of elf (submerged)
        const clipH = Math.floor(TS * 0.6);
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.drawImage(elfC, 0, 0, TILE, Math.floor(TILE * 0.6), ex, ey, TS, clipH);
        ctx.globalAlpha = 1;
        // Water ripples around elf
        const rippleOff = Math.sin(animFrame * 0.15) * 3;
        ctx.fillStyle = 'rgba(66,165,245,0.35)';
        ctx.fillRect(ex - 4 + rippleOff, ey + clipH - 4, TS + 8, 6);
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(ex + 6 - rippleOff, ey + clipH - 6, TS - 12, 3);
        ctx.restore();
    } else {
        ctx.drawImage(elfC, ex, ey, TS, TS);
    }

    // Draw sword swing (not in water)
    if (swinging && !isSwimming) {
        ctx.fillStyle = 'rgba(180,200,220,0.8)';
        const swLen = TS * 0.6;
        if (player.dir === 'right') ctx.fillRect(ex + TS, ey + TS*0.3, swLen, 4);
        else if (player.dir === 'left') ctx.fillRect(ex - swLen, ey + TS*0.3, swLen, 4);
        else if (player.dir === 'down') ctx.fillRect(ex + TS*0.3, ey + TS, 4, swLen);
        else ctx.fillRect(ex + TS*0.3, ey - swLen, 4, swLen);
    }
}

// ============================================
// MOVEMENT & INPUT
// ============================================
const keysDown = {};

function tryMove(dx, dy, dir) {
    if (isMoving || swinging) return;
    player.dir = dir;
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (nx < 0 || nx >= activeMapW || ny < 0 || ny >= activeMapH) return;

    const tileId = gameMap[ny][nx];
    const key = `${nx},${ny}`;

    // Bush acts as walkable if already cut
    if (tileId === T.BUSH && cutBushes.has(key)) {
        startMove(nx, ny); return;
    }
    // Chest acts as walkable if opened (becomes grass)
    if (tileId === T.CHEST && openedChests.has(key)) {
        startMove(nx, ny); return;
    }
    if (!WALKABLE.has(tileId)) return;
    startMove(nx, ny);
}

function startMove(nx, ny) {
    isMoving = true;
    moveFrom.x = player.x;
    moveFrom.y = player.y;
    moveTo.x = nx;
    moveTo.y = ny;
    moveProgress = 0;
}

function interact() {
    // Check tile in front of player
    const dx = player.dir === 'right' ? 1 : player.dir === 'left' ? -1 : 0;
    const dy = player.dir === 'down' ? 1 : player.dir === 'up' ? -1 : 0;
    const tx = player.x + dx;
    const ty = player.y + dy;
    if (tx < 0 || tx >= activeMapW || ty < 0 || ty >= activeMapH) return;

    const key = `${tx},${ty}`;
    const tile = gameMap[ty][tx];

    if (tile === T.CHEST && !openedChests.has(key)) {
        openedChests.add(key);
        // Random reward (keys only come from special bushes)
        const rewards = ['potion', 'shield', 'coins', 'coins', 'coins', 'coins'];
        const reward = rewards[Math.floor(Math.random() * rewards.length)];
        if (reward === 'coins') {
            const amt = Math.floor(Math.random() * 5) + 1;
            playerCoins += amt;
            inventory.coins += amt;
            showNotif(`Found ${amt} coins!`);
        } else {
            inventory[reward] = (inventory[reward] || 0) + 1;
            showNotif(`Found ${ITEM_DEFS[reward].name}!`);
        }
        syncCoins();
        renderBackpack();
        updateHUD();
        saveState();
    } else if (tile === T.DOOR && !insideHouse) {
        // Find which house this door belongs to
        const houseIdx = HOUSE_DOORS.findIndex(h => h.doorX === tx && h.doorY === ty);
        if (houseIdx >= 0) {
            if (inventory.key > 0) {
                inventory.key--;
                doorsOpened++;
                enterHouse(houseIdx);
            } else {
                showNotif('The door is locked... You need a key.');
            }
        }
    }
}

function enterHouse(houseIdx) {
    if (transitioning) return;
    const interior = HOUSE_INTERIORS[houseIdx];
    transitioning = true;
    transitionPhase = 'iris_close';
    transitionProgress = 0;
    transitionCallback = () => {
        // Save overworld state
        overworldMap = gameMap;
        overworldPos = { x: player.x, y: player.y, dir: player.dir };
        // Switch to interior
        insideHouse = true;
        currentInterior = houseIdx;
        gameMap = interior.map.map(row => [...row]); // clone so we don't mutate
        activeMapW = INTERIOR_W;
        activeMapH = INTERIOR_H;
        // Place player on interior door tile
        player.x = interior.doorX;
        player.y = interior.doorY - 1; // one tile above the door
        player.dir = 'up';
        isMoving = false;
        moveProgress = 0;
        // Track visit
        housesVisited.add(houseIdx);
        resizeCanvas();
        showNotif(interior.name);
        renderBackpack();
        updateHUD();
        saveState();
        // Start opening iris
        transitionPhase = 'iris_open';
        transitionProgress = 0;
    };
}

function exitHouse() {
    if (transitioning || !insideHouse) return;
    transitioning = true;
    transitionPhase = 'iris_close';
    transitionProgress = 0;
    transitionCallback = () => {
        // Restore overworld
        gameMap = overworldMap;
        overworldMap = null;
        insideHouse = false;
        activeMapW = MAP_W;
        activeMapH = MAP_H;
        // Place player just below the door
        const houseDoor = HOUSE_DOORS[currentInterior];
        player.x = houseDoor.doorX;
        player.y = houseDoor.doorY + 1;
        player.dir = 'down';
        currentInterior = -1;
        isMoving = false;
        moveProgress = 0;
        resizeCanvas();
        renderBackpack();
        updateHUD();
        saveState();
        // Start opening iris
        transitionPhase = 'iris_open';
        transitionProgress = 0;
    };
}

function swingSword() {
    if (swinging || isMoving) return;
    swinging = true;
    swingTimer = 0.2; // seconds

    // Check for bush in front
    const dx = player.dir === 'right' ? 1 : player.dir === 'left' ? -1 : 0;
    const dy = player.dir === 'down' ? 1 : player.dir === 'up' ? -1 : 0;
    const tx = player.x + dx;
    const ty = player.y + dy;
    if (tx >= 0 && tx < activeMapW && ty >= 0 && ty < activeMapH) {
        const key = `${tx},${ty}`;
        if (gameMap[ty][tx] === T.BUSH && !cutBushes.has(key)) {
            cutBushes.add(key);
            if (KEY_BUSHES.has(key)) {
                // Key bush — always drops a key
                inventory.key = (inventory.key || 0) + 1;
                showNotif('Cut bush — found a Key!');
            } else {
                // Regular bush — sometimes drops coins
                const roll = Math.random();
                if (roll < 0.4) {
                    const amt = Math.floor(Math.random() * 3) + 1;
                    playerCoins += amt;
                    inventory.coins += amt;
                    showNotif(`Cut bush — found ${amt} coins!`);
                    syncCoins();
                } else {
                    showNotif('Cut the bush!');
                }
            }
            renderBackpack();
            updateHUD();
            saveState();
        }
    }
}

// Keyboard
document.addEventListener('keydown', (e) => {
    keysDown[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'e') interact();
    if (e.key === ' ') { e.preventDefault(); swingSword(); }
    if (e.key.toLowerCase() === 'i') toggleBackpack();
    if (e.key.toLowerCase() === 'm') toggleMissions();
});
document.addEventListener('keyup', (e) => {
    keysDown[e.key.toLowerCase()] = false;
});

function processInput() {
    if (isMoving) return;
    if (keysDown['arrowup'] || keysDown['w']) tryMove(0, -1, 'up');
    else if (keysDown['arrowdown'] || keysDown['s']) tryMove(0, 1, 'down');
    else if (keysDown['arrowleft'] || keysDown['a']) tryMove(-1, 0, 'left');
    else if (keysDown['arrowright'] || keysDown['d']) tryMove(1, 0, 'right');
}

// ============================================
// MOBILE CONTROLS
// ============================================
let mobileDir = null;
let mobileHoldTimer = null;

if (isTouchDevice) {
    const dpadBtns = document.querySelectorAll('.dpad-btn');
    dpadBtns.forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mobileDir = btn.dataset.dir;
        });
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (mobileDir === btn.dataset.dir) mobileDir = null;
        });
    });

    document.getElementById('btn-a').addEventListener('touchstart', (e) => {
        e.preventDefault(); swingSword();
    });
    document.getElementById('btn-b').addEventListener('touchstart', (e) => {
        e.preventDefault(); interact();
    });
    document.getElementById('btn-bag').addEventListener('touchstart', (e) => {
        e.preventDefault(); toggleBackpack();
    });
    document.getElementById('btn-quest').addEventListener('touchstart', (e) => {
        e.preventDefault(); toggleMissions();
    });
}

function processMobileInput() {
    if (!mobileDir || isMoving) return;
    const dirs = { up: [0,-1], down: [0,1], left: [-1,0], right: [1,0] };
    const [dx, dy] = dirs[mobileDir];
    tryMove(dx, dy, mobileDir);
}

// ============================================
// BACKPACK
// ============================================
const itemIcons = {};

function initItemIcons() {
    for (const id of Object.keys(ITEM_DEFS)) {
        itemIcons[id] = genItemIcon(id);
    }
}

function renderBackpack() {
    const container = document.getElementById('bp-items');
    container.innerHTML = '';
    for (const [id, def] of Object.entries(ITEM_DEFS)) {
        const count = id === 'coins' ? playerCoins : (inventory[id] || 0);
        if (count <= 0 && id !== 'sword') continue;

        const div = document.createElement('div');
        div.className = 'bp-item' + (id === selectedItem ? ' selected' : '');
        div.onclick = () => { selectedItem = id; renderBackpack(); };

        const icon = itemIcons[id].cloneNode(true);
        div.appendChild(icon);

        const nameSpan = document.createElement('span');
        nameSpan.className = 'item-name';
        nameSpan.textContent = def.name;
        div.appendChild(nameSpan);

        const countSpan = document.createElement('span');
        countSpan.className = 'item-count';
        countSpan.textContent = count > 1 ? `x${count}` : '';
        div.appendChild(countSpan);

        container.appendChild(div);
    }

    // Draw elf portrait
    const portrait = document.getElementById('elf-portrait');
    const pCtx = portrait.getContext('2d');
    pCtx.clearRect(0, 0, 16, 16);
    const portraitSet = inventory.sword > 0 ? elfSwordSprites : elfSprites;
    pCtx.drawImage(portraitSet.down[0], 0, 0);
}

function toggleBackpack() {
    if (isTouchDevice) {
        document.getElementById('backpack').classList.toggle('open');
        document.getElementById('missions').classList.remove('open');
    }
}

// ============================================
// MISSIONS
// ============================================
const MISSIONS = [
    {
        id: 'first_steps',
        name: 'First Steps',
        desc: 'Walk around the village and explore.',
        reward: null,
        check: () => {
            // Complete after walking 20+ tiles
            return (tilesWalked >= 20);
        }
    },
    {
        id: 'treasure_hunter',
        name: 'Treasure Hunter',
        desc: 'Open your first chest.',
        reward: '+5 coins',
        rewardCoins: 5,
        check: () => openedChests.size >= 1
    },
    {
        id: 'lumberjack',
        name: 'Bush Whacker',
        desc: 'Cut down 3 bushes with your sword.',
        reward: '+3 coins',
        rewardCoins: 3,
        check: () => cutBushes.size >= 3
    },
    {
        id: 'collector',
        name: 'Collector',
        desc: 'Gather 10 coins total.',
        reward: null,
        check: () => playerCoins >= 10
    },
    {
        id: 'treasure_master',
        name: 'Treasure Master',
        desc: 'Open all 5 chests in the world.',
        reward: '+15 coins',
        rewardCoins: 15,
        check: () => openedChests.size >= 5
    },
    {
        id: 'herbalist',
        name: 'Herbalist',
        desc: 'Find a potion in a chest.',
        reward: null,
        check: () => inventory.potion >= 1
    },
    {
        id: 'locksmith',
        name: 'Locksmith',
        desc: 'Find a key and use it on a door.',
        reward: null,
        check: () => (doorsOpened >= 1)
    },
    {
        id: 'explorer',
        name: 'Explorer',
        desc: 'Walk across the bridge over the river.',
        reward: '+5 coins',
        rewardCoins: 5,
        check: () => crossedBridge
    },
    {
        id: 'wealthy',
        name: 'Wealthy Elf',
        desc: 'Accumulate 50 coins.',
        reward: null,
        check: () => playerCoins >= 50
    },
    {
        id: 'slash_master',
        name: 'Slash Master',
        desc: 'Cut down 10 bushes.',
        reward: '+10 coins',
        rewardCoins: 10,
        check: () => cutBushes.size >= 10
    },
    {
        id: 'swimmer',
        name: 'Swimmer',
        desc: 'Take a swim in the lake.',
        reward: '+3 coins',
        rewardCoins: 3,
        check: () => hasSwum
    },
    {
        id: 'home_explorer',
        name: 'Home Explorer',
        desc: 'Visit all 4 houses in the village.',
        reward: '+20 coins',
        rewardCoins: 20,
        check: () => housesVisited.size >= 4
    }
];

let completedMissions = new Set();
let tilesWalked = 0;
let doorsOpened = 0;
let crossedBridge = false;
let hasSwum = false;

function checkMissions() {
    let changed = false;
    for (const mission of MISSIONS) {
        if (completedMissions.has(mission.id)) continue;
        if (mission.check()) {
            completedMissions.add(mission.id);
            changed = true;
            showNotif(`Mission complete: ${mission.name}!`);
            if (mission.rewardCoins) {
                playerCoins += mission.rewardCoins;
                inventory.coins = playerCoins;
                syncCoins();
                updateHUD();
                renderBackpack();
            }
            saveState();
        }
    }
    if (changed) renderMissions();
}

function renderMissions() {
    const container = document.getElementById('mission-list');
    container.innerHTML = '';
    for (const mission of MISSIONS) {
        const done = completedMissions.has(mission.id);
        const div = document.createElement('div');
        div.className = 'mission' + (done ? ' done' : '');

        const header = document.createElement('div');
        header.className = 'mission-header';

        const check = document.createElement('div');
        check.className = 'mission-check';
        check.textContent = done ? '✓' : '';
        header.appendChild(check);

        const name = document.createElement('div');
        name.className = 'mission-name';
        name.textContent = mission.name;
        header.appendChild(name);

        div.appendChild(header);

        const desc = document.createElement('div');
        desc.className = 'mission-desc';
        desc.textContent = mission.desc;
        div.appendChild(desc);

        if (mission.reward) {
            const reward = document.createElement('div');
            reward.className = 'mission-reward';
            reward.textContent = done ? 'Claimed' : mission.reward;
            div.appendChild(reward);
        }

        container.appendChild(div);
    }
}

function toggleMissions() {
    if (isTouchDevice) {
        document.getElementById('missions').classList.toggle('open');
        document.getElementById('backpack').classList.remove('open');
    }
}

// ============================================
// HUD
// ============================================
function updateHUD() {
    document.getElementById('d-coins').textContent = `Coins: ${playerCoins}`;
    inventory.coins = playerCoins;

    const heartsDiv = document.getElementById('hud-hearts');
    heartsDiv.innerHTML = '';
    for (let i = 0; i < maxHP; i++) {
        const h = document.createElement('div');
        h.className = 'heart' + (i >= playerHP ? ' empty' : '');
        heartsDiv.appendChild(h);
    }
}

// ============================================
// NOTIFICATIONS
// ============================================
function showNotif(msg) {
    const div = document.createElement('div');
    div.className = 'notif';
    div.textContent = msg;
    document.body.appendChild(div);
    setTimeout(() => div.remove(), 2500);
}

// ============================================
// INTERACTION PROMPT
// ============================================
function updateInteractPrompt() {
    const dx = player.dir === 'right' ? 1 : player.dir === 'left' ? -1 : 0;
    const dy = player.dir === 'down' ? 1 : player.dir === 'up' ? -1 : 0;
    const tx = player.x + dx;
    const ty = player.y + dy;
    const prompt = document.getElementById('interact-prompt');

    if (tx >= 0 && tx < activeMapW && ty >= 0 && ty < activeMapH) {
        const tile = gameMap[ty][tx];
        const key = `${tx},${ty}`;
        if (tile === T.CHEST && !openedChests.has(key)) {
            prompt.innerHTML = isTouchDevice ? 'Press <b>B</b> to open chest' : 'Press <b>E</b> to open chest';
            prompt.style.display = 'block';
            return;
        }
        if (tile === T.DOOR && !insideHouse) {
            const doorMsg = inventory.key > 0 ? 'enter house' : 'locked (need key)';
            prompt.innerHTML = isTouchDevice ? `Press <b>B</b> to ${doorMsg}` : `Press <b>E</b> to ${doorMsg}`;
            prompt.style.display = 'block';
            return;
        }
        if (tile === T.BUSH && !cutBushes.has(key)) {
            const hint = KEY_BUSHES.has(key) ? ' — something shines inside!' : '';
            prompt.innerHTML = (isTouchDevice ? 'Press <b>A</b> to cut' : 'Press <b>Space</b> to cut') + hint;
            prompt.style.display = 'block';
            return;
        }
    }
    prompt.style.display = 'none';
}

// ============================================
// SAVE / LOAD
// ============================================
const SAVE_VERSION = 3; // bump to reset old saves

function saveState() {
    // If inside a house, save overworld position so we reload outside
    const saveX = insideHouse ? overworldPos.x : player.x;
    const saveY = insideHouse ? overworldPos.y : player.y;
    const saveDir = insideHouse ? overworldPos.dir : player.dir;
    const state = {
        version: SAVE_VERSION,
        px: saveX, py: saveY, dir: saveDir,
        hp: playerHP, coins: playerCoins,
        inventory: inventory,
        openedChests: [...openedChests],
        cutBushes: [...cutBushes],
        completedMissions: [...completedMissions],
        tilesWalked: tilesWalked,
        doorsOpened: doorsOpened,
        crossedBridge: crossedBridge,
        hasSwum: hasSwum,
        housesVisited: [...housesVisited]
    };
    localStorage.setItem('elfquest_state', JSON.stringify(state));
}

function loadState() {
    const raw = localStorage.getItem('elfquest_state');
    if (!raw) return false;
    try {
        const s = JSON.parse(raw);
        // Reset if save is from an older map version
        if (!s.version || s.version < SAVE_VERSION) {
            localStorage.removeItem('elfquest_state');
            return false;
        }
        player.x = s.px; player.y = s.py; player.dir = s.dir || 'down';
        playerHP = s.hp || 3;
        playerCoins = s.coins || 0;
        inventory = s.inventory || { sword: 1, shield: 0, key: 0, potion: 0, coins: 0 };
        openedChests = new Set(s.openedChests || []);
        cutBushes = new Set(s.cutBushes || []);
        completedMissions = new Set(s.completedMissions || []);
        tilesWalked = s.tilesWalked || 0;
        doorsOpened = s.doorsOpened || 0;
        crossedBridge = s.crossedBridge || false;
        hasSwum = s.hasSwum || false;
        housesVisited = new Set(s.housesVisited || []);
        return true;
    } catch(e) { return false; }
}

// ============================================
// GAME LOOP
// ============================================
let lastTime = 0;
let saveTimer = 0;
let missionTimer = 0;

function renderIrisWipe() {
    if (!transitioning) return;
    const w = canvas.width;
    const h = canvas.height;
    // Max radius = diagonal / 2
    const maxR = Math.sqrt(w * w + h * h) / 2;
    let radius;
    if (transitionPhase === 'iris_close') {
        radius = maxR * (1 - transitionProgress);
    } else {
        radius = maxR * transitionProgress;
    }
    // Draw black with circular hole
    ctx.save();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.arc(w / 2, h / 2, Math.max(0, radius), 0, Math.PI * 2, true);
    ctx.fill('evenodd');
    ctx.restore();
}

function gameLoop(time) {
    requestAnimationFrame(gameLoop);
    const delta = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;
    animFrame++;

    // Handle transition animation
    if (transitioning) {
        transitionProgress += TRANSITION_SPEED * delta;
        if (transitionProgress >= 1) {
            transitionProgress = 1;
            if (transitionPhase === 'iris_close' && transitionCallback) {
                const cb = transitionCallback;
                transitionCallback = null;
                cb(); // switches map, sets phase to iris_open
            } else if (transitionPhase === 'iris_open') {
                transitioning = false;
                transitionPhase = 'none';
                transitionProgress = 0;
            }
        }
        render();
        renderIrisWipe();
        return; // skip input/game logic during transition
    }

    // Process input
    if (isTouchDevice) processMobileInput();
    else processInput();

    // Movement interpolation
    if (isMoving) {
        // Slow down in water
        const inWater = gameMap[moveTo.y] && gameMap[moveTo.y][moveTo.x] === T.WATER;
        const speed = inWater ? MOVE_SPEED * 0.45 : MOVE_SPEED;
        moveProgress += speed * delta;
        if (moveProgress >= 1) {
            moveProgress = 0;
            isMoving = false;
            player.x = moveTo.x;
            player.y = moveTo.y;
            tilesWalked++;
            // Check bridge crossing
            if (gameMap[player.y] && gameMap[player.y][player.x] === T.BRIDGE) {
                crossedBridge = true;
            }
            // Check swimming
            if (gameMap[player.y] && gameMap[player.y][player.x] === T.WATER) {
                hasSwum = true;
            }
            // Check IDOOR — auto-exit house
            if (insideHouse && gameMap[player.y] && gameMap[player.y][player.x] === T.IDOOR) {
                exitHouse();
            }
        }
    }

    // Sword swing timer
    if (swinging) {
        swingTimer -= delta;
        if (swingTimer <= 0) swinging = false;
    }

    // Check missions every 2 seconds
    missionTimer += delta;
    if (missionTimer > 2) {
        missionTimer = 0;
        checkMissions();
    }

    // Auto-save
    saveTimer += delta;
    if (saveTimer > 15) {
        saveTimer = 0;
        saveState();
    }

    updateInteractPrompt();
    render();
}

// ============================================
// INIT
// ============================================
function init() {
    checkAuth();
    initElfSprites();
    initItemIcons();
    gameMap = createMap();
    loadState();
    resizeCanvas();
    renderBackpack();
    renderMissions();
    updateHUD();
    requestAnimationFrame(gameLoop);
}

window.addEventListener('resize', resizeCanvas);
init();
</script>
</body>
</html>

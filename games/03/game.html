<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BlogCraft</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        canvas { display: block; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; right: 0;
            pointer-events: none; z-index: 100;
        }
        #hud-top {
            display: flex; justify-content: space-between; padding: 8px 12px;
            background: rgba(0,0,0,0.5);
        }
        #hud-left { color: #fff; font-size: 13px; }
        #hud-left .val { font-weight: bold; }
        .hud-username { color: gold; }
        .hud-coins { color: lime; margin-left: 10px; }
        .hud-followers { color: #e94560; margin-left: 10px; }
        .hud-rank { color: #9c27b0; margin-left: 10px; }
        .hud-time { color: #ffab40; margin-left: 10px; }
        #hud-right { pointer-events: auto; }
        #hud-right a {
            color: #aaa; font-size: 13px; text-decoration: none; margin-left: 10px; cursor: pointer;
        }
        #hud-right a:hover { color: #fff; }

        /* Crosshair */
        #crosshair {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font-size: 24px; z-index: 101;
            pointer-events: none; text-shadow: 1px 1px 2px #000;
        }

        /* Hotbar */
        #hotbar {
            position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 3px; z-index: 100;
            background: rgba(0,0,0,0.6); padding: 4px; border-radius: 6px;
        }
        .hotbar-slot {
            width: 48px; height: 48px;
            border: 2px solid #555; border-radius: 4px;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; position: relative;
            background: rgba(0,0,0,0.4);
        }
        .hotbar-slot.selected { border-color: gold; background: rgba(255,215,0,0.15); }
        .hotbar-slot .slot-color {
            width: 24px; height: 24px; border-radius: 3px;
            image-rendering: pixelated;
        }
        .hotbar-slot .slot-count {
            position: absolute; bottom: 1px; right: 3px;
            font-size: 10px; color: #fff; font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }
        .hotbar-slot .slot-key {
            position: absolute; top: 1px; left: 3px;
            font-size: 9px; color: #888;
        }

        /* Click to play overlay */
        #start-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7); z-index: 200;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #fff; cursor: pointer;
        }
        #start-overlay h1 { color: gold; font-size: 36px; margin-bottom: 10px; }
        #start-overlay p { font-size: 16px; color: #aaa; margin: 4px; }
        #start-overlay .controls-help {
            margin-top: 20px; font-size: 13px; color: #888;
            text-align: center; line-height: 1.8;
        }
        #start-overlay.hidden { display: none; }

        /* Crafting Panel */
        #craft-panel {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,40,0.97);
            border: 2px solid #555; border-radius: 10px;
            padding: 20px; z-index: 150;
            min-width: 340px; max-height: 85vh; overflow-y: auto;
            display: none;
        }
        #craft-panel.open { display: block; }
        #craft-panel h2 { color: gold; text-align: center; margin-bottom: 14px; font-size: 18px; }
        #craft-grid-area {
            display: flex; align-items: center;
            justify-content: center; gap: 16px;
            margin-bottom: 12px;
        }
        #craft-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }
        .craft-slot {
            width: 52px; height: 52px;
            border: 2px solid #444; border-radius: 4px;
            background: rgba(0,0,0,0.5);
            cursor: pointer; position: relative;
            display: flex; align-items: center; justify-content: center;
            transition: border-color 0.1s;
        }
        .craft-slot:hover { border-color: #aaa; }
        .craft-slot.has-item { border-color: #777; }
        .craft-slot .cs-swatch {
            width: 34px; height: 34px; border-radius: 3px;
            image-rendering: pixelated; background-size: cover;
        }
        .craft-slot .cs-count {
            position: absolute; bottom: 1px; right: 3px;
            font-size: 10px; color: #fff; font-weight: bold;
            text-shadow: 1px 1px 1px #000; pointer-events: none;
        }
        #craft-arrow { color: gold; font-size: 26px; flex-shrink: 0; }
        #craft-output-area { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        #craft-output-slot {
            width: 60px; height: 60px;
            border: 2px solid #555; border-radius: 6px;
            background: rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center;
            position: relative; font-size: 28px;
            transition: border-color 0.15s;
        }
        #craft-output-slot.has-result { border-color: gold; }
        #craft-output-slot .cs-swatch { width: 42px; height: 42px; border-radius: 3px; image-rendering: pixelated; background-size: cover; }
        #craft-output-slot .cs-count { position: absolute; bottom: 2px; right: 4px; font-size: 11px; color: #fff; font-weight: bold; text-shadow: 1px 1px 1px #000; }
        #craft-output-name { font-size: 12px; color: #fff; text-align: center; min-height: 16px; }
        #craft-output-info { font-size: 11px; color: #9c27b0; text-align: center; min-height: 14px; }
        #do-craft-btn {
            display: block; margin: 0 auto 10px;
            padding: 7px 28px; border: none; border-radius: 5px;
            font-size: 13px; font-weight: bold; cursor: pointer;
            background: #4CAF50; color: #fff;
        }
        #do-craft-btn:disabled { background: #555; cursor: default; }
        #clear-grid-btn {
            display: block; margin: 0 auto 14px;
            padding: 5px 18px; border: none; border-radius: 4px;
            font-size: 12px; cursor: pointer;
            background: #444; color: #aaa;
        }
        #clear-grid-btn:hover { background: #555; }
        #craft-inventory h3 { font-size: 12px; color: #888; text-align: center; margin-bottom: 8px; }
        #craft-inv-list { display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; margin-bottom: 12px; }
        .inv-item {
            width: 46px; height: 46px;
            border: 2px solid #444; border-radius: 4px;
            background: rgba(0,0,0,0.4); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            position: relative; transition: border-color 0.1s;
        }
        .inv-item:hover { border-color: #888; }
        .inv-item.selected { border-color: gold; background: rgba(255,215,0,0.15); }
        .inv-item .inv-swatch { width: 28px; height: 28px; border-radius: 2px; image-rendering: pixelated; background-size: cover; }
        .inv-item .inv-count { position: absolute; bottom: 1px; right: 3px; font-size: 10px; color: #fff; font-weight: bold; text-shadow: 1px 1px 1px #000; }
        #craft-close {
            display: block; margin: 0 auto; padding: 8px 20px;
            background: #e94560; color: #fff; border: none; border-radius: 5px;
            font-size: 14px; cursor: pointer;
        }

        /* Notification */
        .notif {
            position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); color: #fff; padding: 8px 16px;
            border-radius: 6px; font-size: 14px; z-index: 200;
            border-left: 3px solid gold;
            animation: notifIn 0.3s ease;
        }
        @keyframes notifIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

        /* Mining progress */
        #mine-progress {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, 20px);
            width: 60px; height: 5px; background: #333; border-radius: 3px;
            overflow: hidden; z-index: 101; display: none;
        }
        #mine-progress-fill { height: 100%; background: gold; width: 0%; }

        /* Mobile controls */
        #mobile-controls { display: none; position: fixed; z-index: 110; }
        #joystick-area {
            position: fixed; bottom: 20px; left: 20px;
            width: 120px; height: 120px;
            background: rgba(255,255,255,0.1); border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
        }
        #joystick-knob {
            width: 40px; height: 40px; background: rgba(255,255,255,0.4);
            border-radius: 50%; position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .mobile-btn {
            position: fixed; width: 50px; height: 50px;
            background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; color: #fff; font-size: 12px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
        }
        #btn-jump { bottom: 80px; right: 20px; }

        #btn-craft { bottom: 80px; right: 80px; }

        /* Mobile: shown via JS class on body */
        body.is-touch #mobile-controls { display: block; }
        body.is-touch .hotbar-slot { width: 38px; height: 38px; }
        body.is-touch .hotbar-slot .slot-color { width: 18px; height: 18px; }
        body.is-touch #hotbar { bottom: 70px; }
        body.is-touch #crosshair { display: none; }
        body.is-touch .controls-help-desktop { display: none; }
        body:not(.is-touch) .controls-help-mobile { display: none; }
    </style>
</head>
<body>

<!-- Start Overlay -->
<div id="start-overlay">
    <h1>BlogCraft</h1>
    <p>A 3D voxel world of mining, crafting & blogging</p>
    <p style="color:gold; margin-top:15px;" id="start-action">Click to Play</p>
    <div class="controls-help controls-help-desktop">
        WASD - Move | S+W - Sprint | Mouse - Look | Space - Jump<br>
        Left Click - Mine | Right Click - Place<br>
        1-9 - Select Slot | E - Crafting
    </div>
    <div class="controls-help controls-help-mobile">
        Left Joystick - Move | Right Side - Look<br>
        Tap - Build | Hold - Mine<br>
        Tap Hotbar - Select Slot | E Button - Crafting
    </div>
</div>

<!-- HUD -->
<div id="hud">
    <div id="hud-top">
        <div id="hud-left">
            <span class="hud-username val" id="d-name"></span>
            <span class="hud-coins">Coins: <span class="val" id="d-coins">0</span></span>
            <span class="hud-followers">Followers: <span class="val" id="d-followers">0</span></span>
            <span class="hud-rank">Rank: <span class="val" id="d-rank">Newbie</span></span>
            <span class="hud-time"><span class="val" id="d-time">☀ 12:00</span></span>
        </div>
        <div id="hud-right">
            <a href="/games/01/home.html">Home</a>
            <a onclick="handleLogout()">Logout</a>
        </div>
    </div>
</div>

<!-- Crosshair -->
<div id="crosshair">+</div>
<div id="sprint-indicator" style="display:none; position:fixed; bottom:70px; left:50%; transform:translateX(-50%); color:#ffd700; font-size:13px; font-weight:bold; z-index:101; pointer-events:none; text-shadow:1px 1px 2px #000; letter-spacing:1px;">SPRINTING</div>

<!-- Mining progress -->
<div id="mine-progress"><div id="mine-progress-fill"></div></div>

<!-- Hotbar -->
<div id="hotbar"></div>

<!-- Crafting Panel -->
<div id="craft-panel">
    <h2>Crafting Table</h2>
    <div id="craft-grid-area">
        <div id="craft-grid"></div>
        <div id="craft-arrow">➜</div>
        <div id="craft-output-area">
            <div id="craft-output-slot"></div>
            <div id="craft-output-name"></div>
            <div id="craft-output-info"></div>
        </div>
    </div>
    <button id="do-craft-btn" disabled onclick="doCraft()">Craft</button>
    <button id="clear-grid-btn" onclick="clearCraftGrid()">Clear Grid</button>
    <div id="craft-inventory">
        <h3>Your items — click to select, then click a grid slot</h3>
        <div id="craft-inv-list"></div>
    </div>
    <button id="craft-close" onclick="toggleCraft()">Close (E)</button>
</div>

<!-- Mobile Controls -->
<div id="mobile-controls">
    <div id="joystick-area"><div id="joystick-knob"></div></div>
    <div class="mobile-btn" id="btn-jump">Jump</div>
    <div class="mobile-btn" id="btn-craft">E</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================
// DEVICE DETECTION
// ============================================
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
if (isTouchDevice) {
    document.body.classList.add('is-touch');
    document.getElementById('start-action').textContent = 'Tap to Play';
}

// ============================================
// AUTH
// ============================================
const API_URL = '/games/01/api';
let currentUser = null, authToken = null;

function checkAuth() {
    const u = localStorage.getItem('user'), t = localStorage.getItem('token');
    if (!u || !t) { window.location.href = '/games/01/login.html'; return; }
    currentUser = JSON.parse(u);
    authToken = t;
    document.getElementById('d-name').textContent = currentUser.name;
    document.getElementById('d-coins').textContent = currentUser.coins || 0;
}

function handleLogout() {
    localStorage.removeItem('user');
    localStorage.removeItem('token');
    window.location.href = '/games/01/login.html';
}

// ============================================
// BLOCK TYPES
// ============================================
const BLOCKS = {
    grass:   { name: 'Grass',   color: 0x4CAF50, topColor: 0x66BB6A, sideColor: 0x795548 },
    dirt:    { name: 'Dirt',    color: 0x795548 },
    stone:   { name: 'Stone',   color: 0x9E9E9E },
    wood:    { name: 'Wood',    color: 0x5D4037 },
    leaves:  { name: 'Leaves',  color: 0x2E7D32 },
    iron:    { name: 'Iron',    color: 0xB0BEC5 },
    gold:    { name: 'Gold',    color: 0xFFD700 },
    crystal: { name: 'Crystal', color: 0x00BCD4 },
    planks:  { name: 'Planks',  color: 0xD7A86E },
    paper:   { name: 'Paper',   color: 0xF5F5DC },
    blogpost:{ name: 'Blog Post', color: 0xE91E63 },
};

// ============================================
// RECIPES
// ============================================
// Grid patterns: 2D arrays, null = empty slot. Shape and position within the
// bounding box must match exactly (mirroring supported where mirror:true).
const RECIPES = [
    {
        name: 'Planks',
        pattern: [['wood']],
        output: { type: 'planks', count: 4 },
    },
    {
        name: 'Paper',
        pattern: [['planks', 'planks', 'planks']],
        output: { type: 'paper', count: 3 },
    },
    {
        name: 'Blog Post',
        pattern: [['paper'], ['leaves'], ['paper']],
        output: { type: 'blogpost', count: 1 },
    },
    {
        name: 'Stone Pickaxe',
        pattern: [['stone', 'stone', 'stone'], [null, 'wood', null], [null, 'wood', null]],
        output: null, special: 'pickaxe_stone',
        resultText: 'Equip: +50% mine speed',
    },
    {
        name: 'Iron Pickaxe',
        pattern: [['iron', 'iron', 'iron'], [null, 'wood', null], [null, 'wood', null]],
        output: null, special: 'pickaxe_iron',
        resultText: 'Equip: +100% mine speed',
    },
    {
        name: 'Publish!',
        pattern: [['blogpost']],
        output: null, special: 'publish',
        resultText: 'Earns followers + coins',
    },
];

// ============================================
// RANKS
// ============================================
const RANKS = [
    { name: 'Newbie', followers: 0 },
    { name: 'Hobbyist', followers: 50 },
    { name: 'Writer', followers: 200 },
    { name: 'Journalist', followers: 500 },
    { name: 'Influencer', followers: 2000 },
    { name: 'Legend', followers: 10000 },
];

// ============================================
// GAME STATE
// ============================================
const WORLD_SIZE = 32;
const WORLD_HEIGHT = 8;
let world = {}; // key: "x,y,z" -> blockType string
// Instanced rendering — one InstancedMesh per block type, drastically reduces draw calls
const INST_MAX = 6000;
const instancedMeshes = {};  // type -> THREE.InstancedMesh
const instSlots = {};        // type -> Array<string> (instanceId -> "x,y,z")
const blockInstInfo = {};    // "x,y,z" -> {type, idx}
const _tmpMatrix = new THREE.Matrix4();
const texDataURLCache = {}; // texKey -> data URL, populated once per texture

let inventory = {}; // blockType -> count
let hotbar = [null,null,null,null,null,null,null,null,null]; // each: {type, count} or null
let selectedSlot = 0;
let followers = 0;
let pickaxeLevel = 0; // 0=hand, 1=stone, 2=iron
let craftOpen = false;
let craftGrid = [null,null,null,null,null,null,null,null,null]; // 9 slots, row-major
let selectedCraftItem = null; // item type currently held to place in grid


// Day/night cycle — one full day = 10 real minutes (600s)
const DAY_DURATION = 600; // seconds per full day
let gameTime = 0.25; // 0-1, 0=midnight, 0.25=sunrise, 0.5=noon, 0.75=sunset

// Movement state
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let canJump = true;
let isSprinting = false;
let velocity = new THREE.Vector3();
let playerHeight = 1.7;
let isPointerLocked = false;

// Mining state
let miningTarget = null, miningTime = 0, miningDuration = 500;
let isMining = false;
let mineScreenX, mineScreenY; // screen coords for mobile, undefined for desktop (center)
let mineTargetKey = null; // "x,y,z" of block being mined

// Chicken state
let chickens = [];
let chickenSpawnTimer = 0;

// ============================================
// THREE.JS SETUP
// ============================================
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87CEEB, 30, 60);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(WORLD_SIZE / 2, 5, WORLD_SIZE / 2);

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(20, 30, 10);
scene.add(dirLight);

// Raycaster for block interaction
const raycaster = new THREE.Raycaster();
raycaster.far = 6;

// Sky camera — follows main camera rotation, stays at origin, renders sun/moon/stars without fog
const skyCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);

// First-person right hand — separate overlay scene (renders on top)
const handScene = new THREE.Scene();
const handCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 10);
handScene.add(new THREE.AmbientLight(0xffffff, 1.0));

function makeHandTexture(drawFn) {
    const c = document.createElement('canvas');
    c.width = 16; c.height = 16;
    const ctx = c.getContext('2d');
    drawFn(ctx);
    const tex = new THREE.CanvasTexture(c);
    tex.magFilter = THREE.NearestFilter;
    tex.minFilter = THREE.NearestFilter;
    return tex;
}

function createHandMesh() {
    const group = new THREE.Group();
    const rng = mulberry32(777);

    // Skin texture — varied tan pixels like Steve's skin
    const skinTex = makeHandTexture(ctx => {
        for (let y = 0; y < 16; y++) {
            for (let x = 0; x < 16; x++) {
                const v = Math.floor((rng() - 0.5) * 20);
                const r = Math.max(0, Math.min(255, 212 + v));
                const g = Math.max(0, Math.min(255, 165 + v));
                const b = Math.max(0, Math.min(255, 116 + v));
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Sleeve texture — green shirt with darker seam edges
    const sleeveTex = makeHandTexture(ctx => {
        for (let y = 0; y < 16; y++) {
            for (let x = 0; x < 16; x++) {
                const edge = (x === 0 || x === 15 || y === 0 || y === 15);
                const v = Math.floor((rng() - 0.5) * 18);
                const baseR = edge ? 70 : 91;
                const baseG = edge ? 110 : 140;
                const baseB = edge ? 45 : 62;
                const r = Math.max(0, Math.min(255, baseR + v));
                const g = Math.max(0, Math.min(255, baseG + v));
                const b = Math.max(0, Math.min(255, baseB + v));
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    const skinMat = new THREE.MeshBasicMaterial({ map: skinTex });
    const sleeveMat = new THREE.MeshBasicMaterial({ map: sleeveTex });

    // Arm — vertical sleeve
    const arm = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.5, 0.22), sleeveMat);
    arm.position.set(0, -0.15, 0);
    group.add(arm);

    // Hand — skin block on top
    const hand = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.25, 0.22), skinMat);
    hand.position.set(0, 0.22, 0);
    group.add(hand);

    return group;
}

const handGroup = createHandMesh();
// Bottom-right corner, straight vertical like Minecraft
// FOV 70 at z=1: visible x is ~[-0.7, 0.7], so x=0.45 puts it at the right edge
handGroup.position.set(0.55, -0.4, -0.8);
handGroup.rotation.set(0, 0, Math.PI / 4); // 45 degree tilt
handScene.add(handGroup);

let handBobPhase = 0;
const handRestPos = { x: 0.55, y: -0.4, z: -0.8 };
const handRestRot = { x: 0, y: 0, z: Math.PI / 4 };

// Euler for camera rotation
let euler = new THREE.Euler(0, 0, 0, 'YXZ');

// ============================================
// WORLD GENERATION
// ============================================
// Block geometry (shared)
const blockGeo = new THREE.BoxGeometry(1, 1, 1);

// ---- Pixel texture generator ----
const TEX_SIZE = 16;

function makeTexture(drawFn) {
    const c = document.createElement('canvas');
    c.width = TEX_SIZE; c.height = TEX_SIZE;
    const ctx = c.getContext('2d');
    drawFn(ctx);
    const tex = new THREE.CanvasTexture(c);
    tex.magFilter = THREE.NearestFilter;
    tex.minFilter = THREE.NearestFilter;
    return tex;
}

function hexToRgb(hex) {
    return [(hex >> 16) & 0xff, (hex >> 8) & 0xff, hex & 0xff];
}

function varyColor(r, g, b, amount, rng) {
    const v = Math.floor((rng() - 0.5) * amount * 2);
    return `rgb(${Math.max(0,Math.min(255,r+v))},${Math.max(0,Math.min(255,g+v))},${Math.max(0,Math.min(255,b+v))})`;
}

function fillPixelNoise(ctx, baseHex, variance, rng) {
    const [r, g, b] = hexToRgb(baseHex);
    for (let y = 0; y < TEX_SIZE; y++) {
        for (let x = 0; x < TEX_SIZE; x++) {
            ctx.fillStyle = varyColor(r, g, b, variance, rng);
            ctx.fillRect(x, y, 1, 1);
        }
    }
}

// Pre-generate textures for each block type
const blockTextures = {};

function genTextures() {
    const rng = mulberry32(123);

    // Grass top - 4 shades of green (darker)
    blockTextures.grass_top = makeTexture(ctx => {
        const greens = [0x357A38, 0x4E8C51, 0x2E6B30, 0x3A7D3E];
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const base = greens[Math.floor(rng() * greens.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 12, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Grass side - dirt with green top strip
    blockTextures.grass_side = makeTexture(ctx => {
        // Dirt body
        fillPixelNoise(ctx, 0x795548, 15, rng);
        // Green top 3 pixels with jagged edge
        const greens = [0x357A38, 0x4E8C51, 0x2E6B30, 0x3A7D3E];
        for (let x = 0; x < TEX_SIZE; x++) {
            const depth = 2 + Math.floor(rng() * 2);
            for (let y = 0; y < depth; y++) {
                const base = greens[Math.floor(rng() * greens.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 10, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Dirt
    blockTextures.dirt = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x795548, 18, rng);
        // Occasional darker spots
        for (let i = 0; i < 8; i++) {
            ctx.fillStyle = varyColor(90, 60, 40, 10, rng);
            ctx.fillRect(Math.floor(rng()*TEX_SIZE), Math.floor(rng()*TEX_SIZE), 1, 1);
        }
    });

    // Stone
    blockTextures.stone = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x9E9E9E, 20, rng);
        // Cracks / darker lines
        for (let i = 0; i < 5; i++) {
            ctx.fillStyle = varyColor(100, 100, 100, 15, rng);
            const sx = Math.floor(rng()*TEX_SIZE);
            const sy = Math.floor(rng()*TEX_SIZE);
            ctx.fillRect(sx, sy, 1 + Math.floor(rng()*3), 1);
        }
    });

    // Wood - vertical grain
    blockTextures.wood = makeTexture(ctx => {
        const browns = [0x5D4037, 0x4E342E, 0x6D4C41, 0x795548];
        for (let x = 0; x < TEX_SIZE; x++) {
            const base = browns[x % browns.length];
            for (let y = 0; y < TEX_SIZE; y++) {
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 10, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Wood top - rings
    blockTextures.wood_top = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x6D4C41, 12, rng);
        // Simple ring pattern
        const cx = 8, cy = 8;
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const dist = Math.sqrt((x-cx)*(x-cx)+(y-cy)*(y-cy));
                if (Math.floor(dist) % 3 === 0) {
                    ctx.fillStyle = varyColor(70, 50, 30, 8, rng);
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    });

    // Leaves - scattered light/dark greens
    blockTextures.leaves = makeTexture(ctx => {
        const greens = [0x2E7D32, 0x1B5E20, 0x388E3C, 0x256D27];
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const base = greens[Math.floor(rng() * greens.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 15, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
        // Gaps (transparency effect via darker pixels)
        for (let i = 0; i < 12; i++) {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(Math.floor(rng()*TEX_SIZE), Math.floor(rng()*TEX_SIZE), 1, 1);
        }
    });

    // Iron ore - stone with silver flecks
    blockTextures.iron = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x9E9E9E, 15, rng);
        for (let i = 0; i < 10; i++) {
            ctx.fillStyle = varyColor(190, 200, 210, 10, rng);
            const sx = Math.floor(rng()*14)+1, sy = Math.floor(rng()*14)+1;
            ctx.fillRect(sx, sy, 2, 2);
        }
    });

    // Gold ore - stone with gold flecks
    blockTextures.gold = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x9E9E9E, 15, rng);
        for (let i = 0; i < 8; i++) {
            ctx.fillStyle = varyColor(255, 200, 0, 15, rng);
            const sx = Math.floor(rng()*14)+1, sy = Math.floor(rng()*14)+1;
            ctx.fillRect(sx, sy, 2, 2);
        }
    });

    // Crystal - cyan with sparkle
    blockTextures.crystal = makeTexture(ctx => {
        const cyans = [0x00BCD4, 0x00ACC1, 0x0097A7, 0x26C6DA];
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const base = cyans[Math.floor(rng() * cyans.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 20, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
        // White sparkle pixels
        for (let i = 0; i < 6; i++) {
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.fillRect(Math.floor(rng()*TEX_SIZE), Math.floor(rng()*TEX_SIZE), 1, 1);
        }
    });

    // Planks - horizontal wood grain
    blockTextures.planks = makeTexture(ctx => {
        const tans = [0xD7A86E, 0xC9975C, 0xE0B87E, 0xBF8A50];
        for (let y = 0; y < TEX_SIZE; y++) {
            const base = tans[Math.floor(y / 4) % tans.length];
            for (let x = 0; x < TEX_SIZE; x++) {
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 10, rng);
                ctx.fillRect(x, y, 1, 1);
            }
            // Plank divider line
            if (y % 4 === 0) {
                for (let x = 0; x < TEX_SIZE; x++) {
                    ctx.fillStyle = varyColor(140, 100, 50, 8, rng);
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    });

    // Paper
    blockTextures.paper = makeTexture(ctx => {
        fillPixelNoise(ctx, 0xF5F5DC, 8, rng);
        // Faint lines
        for (let y = 3; y < TEX_SIZE; y += 4) {
            for (let x = 0; x < TEX_SIZE; x++) {
                ctx.fillStyle = 'rgba(180,180,160,0.4)';
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Blog post - pinkish with text lines
    blockTextures.blogpost = makeTexture(ctx => {
        fillPixelNoise(ctx, 0xE91E63, 15, rng);
        // White text lines
        for (let y = 3; y < TEX_SIZE; y += 3) {
            for (let x = 2; x < 14; x++) {
                if (rng() > 0.3) {
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    });
}

function getBlockMaterial(type) {
    const b = BLOCKS[type];
    if (!b) return new THREE.MeshLambertMaterial({ color: 0xff00ff });
    // Single material per type — InstancedMesh requires one material per mesh
    if (type === 'grass') return new THREE.MeshLambertMaterial({ map: blockTextures.grass_top });
    if (type === 'wood')  return new THREE.MeshLambertMaterial({ map: blockTextures.wood });
    if (type === 'leaves') return new THREE.MeshLambertMaterial({ map: blockTextures.leaves, transparent: true, opacity: 0.9 });
    if (blockTextures[type]) return new THREE.MeshLambertMaterial({ map: blockTextures[type] });
    return new THREE.MeshLambertMaterial({ color: b.color });
}

// Material cache
const materialCache = {};
function getCachedMaterial(type) {
    if (!materialCache[type]) materialCache[type] = getBlockMaterial(type);
    return materialCache[type];
}

function initInstanced() {
    for (const type of Object.keys(BLOCKS)) {
        const im = new THREE.InstancedMesh(blockGeo, getCachedMaterial(type), INST_MAX);
        im.count = 0;
        im.userData.blockType = type;
        scene.add(im);
        instancedMeshes[type] = im;
        instSlots[type] = [];
    }
}

function removeInstance(key) {
    const info = blockInstInfo[key];
    if (!info) return;
    const { type, idx } = info;
    const im = instancedMeshes[type];
    const lastIdx = im.count - 1;
    if (idx !== lastIdx) {
        const lastKey = instSlots[type][lastIdx];
        im.getMatrixAt(lastIdx, _tmpMatrix);
        im.setMatrixAt(idx, _tmpMatrix);
        instSlots[type][idx] = lastKey;
        blockInstInfo[lastKey].idx = idx;
    }
    im.count--;
    instSlots[type].length = im.count;
    delete blockInstInfo[key];
    im.instanceMatrix.needsUpdate = true;
}

// ---- Crack overlay system ----
const CRACK_STAGES = 4;
const crackTextures = [];
const crackMaterials = [];
let crackMesh = null;

function genCrackTextures() {
    const crackGeo = new THREE.BoxGeometry(1.005, 1.005, 1.005);
    for (let stage = 0; stage < CRACK_STAGES; stage++) {
        const c = document.createElement('canvas');
        c.width = TEX_SIZE; c.height = TEX_SIZE;
        const ctx = c.getContext('2d');
        // Transparent background
        ctx.clearRect(0, 0, TEX_SIZE, TEX_SIZE);
        const rng = mulberry32(stage * 137 + 7);
        const alpha = 0.4 + stage * 0.15;
        // Draw crack lines
        const numCracks = 2 + stage * 3;
        ctx.strokeStyle = `rgba(30,20,10,${alpha})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < numCracks; i++) {
            ctx.beginPath();
            let x = Math.floor(rng() * TEX_SIZE);
            let y = Math.floor(rng() * TEX_SIZE);
            ctx.moveTo(x, y);
            const segs = 2 + Math.floor(rng() * (2 + stage));
            for (let s = 0; s < segs; s++) {
                x += Math.floor((rng() - 0.5) * 7);
                y += Math.floor((rng() - 0.5) * 7);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        // Add dark chips for higher stages
        if (stage >= 1) {
            ctx.fillStyle = `rgba(20,15,5,${0.15 + stage * 0.1})`;
            for (let i = 0; i < stage * 3; i++) {
                const sx = Math.floor(rng() * TEX_SIZE);
                const sy = Math.floor(rng() * TEX_SIZE);
                const sw = 1 + Math.floor(rng() * 2);
                ctx.fillRect(sx, sy, sw, sw);
            }
        }
        // Final stage gets heavier damage
        if (stage === 3) {
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            for (let i = 0; i < 6; i++) {
                const sx = Math.floor(rng() * TEX_SIZE);
                const sy = Math.floor(rng() * TEX_SIZE);
                ctx.fillRect(sx, sy, 2, 2);
            }
        }
        const tex = new THREE.CanvasTexture(c);
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        crackTextures.push(tex);
        crackMaterials.push(new THREE.MeshBasicMaterial({
            map: tex, transparent: true, depthWrite: false, polygonOffset: true,
            polygonOffsetFactor: -1, polygonOffsetUnits: -1
        }));
    }
    crackMesh = new THREE.Mesh(crackGeo, crackMaterials[0]);
    crackMesh.visible = false;
    crackMesh.renderOrder = 1;
    scene.add(crackMesh);
}

function showCrackOverlay(bx, by, bz, progress) {
    if (!crackMesh) { hideCrackOverlay(); return; }
    const stage = Math.min(Math.floor(progress * CRACK_STAGES), CRACK_STAGES - 1);
    crackMesh.position.set(bx + 0.5, by + 0.5, bz + 0.5);
    crackMesh.material = crackMaterials[stage];
    crackMesh.visible = true;
}

function hideCrackOverlay() {
    if (crackMesh) crackMesh.visible = false;
}

// ---- Hidden-face culling helpers ----
const DIRS6 = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];

function isBlockVisible(x, y, z) {
    for (const [dx, dy, dz] of DIRS6) {
        const ny = y + dy;
        if (ny < 0) continue; // treat below bedrock as solid
        if (!world[`${x+dx},${ny},${z+dz}`]) return true;
    }
    return false;
}

function createBlockMesh(x, y, z, type) {
    const key = `${x},${y},${z}`;
    if (blockInstInfo[key]) return;
    const im = instancedMeshes[type];
    const idx = im.count++;
    instSlots[type][idx] = key;
    blockInstInfo[key] = { type, idx };
    _tmpMatrix.makeTranslation(x + 0.5, y + 0.5, z + 0.5);
    im.setMatrixAt(idx, _tmpMatrix);
    im.instanceMatrix.needsUpdate = true;
}

// Rebuild all instanced meshes from world data — call after bulk world changes
function rebuildMeshes() {
    for (const type of Object.keys(BLOCKS)) {
        if (instancedMeshes[type]) instancedMeshes[type].count = 0;
        instSlots[type] = [];
    }
    for (const key in blockInstInfo) delete blockInstInfo[key];
    for (const [key, type] of Object.entries(world)) {
        const [x, y, z] = key.split(',').map(Number);
        if (isBlockVisible(x, y, z)) createBlockMesh(x, y, z, type);
    }
    for (const type of Object.keys(BLOCKS)) {
        if (instancedMeshes[type]) instancedMeshes[type].instanceMatrix.needsUpdate = true;
    }
}

function addBlock(x, y, z, type) {
    const key = `${x},${y},${z}`;
    world[key] = type;
    if (isBlockVisible(x, y, z)) createBlockMesh(x, y, z, type);
    // Update neighbors: new block may hide them, or previously-hidden ones may need meshes
    for (const [dx, dy, dz] of DIRS6) {
        const nx = x+dx, ny = y+dy, nz = z+dz;
        const nkey = `${nx},${ny},${nz}`;
        if (!world[nkey]) continue;
        if (!isBlockVisible(nx, ny, nz)) {
            removeInstance(nkey);
        } else if (!blockInstInfo[nkey]) {
            createBlockMesh(nx, ny, nz, world[nkey]);
        }
    }
}

function removeBlock(x, y, z) {
    const key = `${x},${y},${z}`;
    delete world[key];
    removeInstance(key);
    // Neighbors that were fully enclosed may now need a mesh
    for (const [dx, dy, dz] of DIRS6) {
        const nx = x+dx, ny = y+dy, nz = z+dz;
        const nkey = `${nx},${ny},${nz}`;
        if (world[nkey] && !blockInstInfo[nkey]) createBlockMesh(nx, ny, nz, world[nkey]);
    }
}

function generateWorld() {
    const rng = mulberry32(42); // seeded RNG for consistent world

    // Build world data first, then create meshes in one pass
    for (let x = 0; x < WORLD_SIZE; x++) {
        for (let z = 0; z < WORLD_SIZE; z++) {
            world[`${x},0,${z}`] = 'stone';
            world[`${x},1,${z}`] = 'dirt';
            world[`${x},2,${z}`] = 'grass';
            const oreRoll = rng();
            if (oreRoll < 0.03)       world[`${x},0,${z}`] = 'gold';
            else if (oreRoll < 0.08)  world[`${x},0,${z}`] = 'iron';
            else if (oreRoll < 0.10)  world[`${x},0,${z}`] = 'crystal';
        }
    }

    for (let i = 0; i < 20; i++) {
        const tx = Math.floor(rng() * (WORLD_SIZE - 4)) + 2;
        const tz = Math.floor(rng() * (WORLD_SIZE - 4)) + 2;
        const height = 3 + Math.floor(rng() * 3);
        for (let h = 0; h < height; h++) world[`${tx},${3+h},${tz}`] = 'wood';
        const topY = 3 + height;
        for (let dx = -2; dx <= 2; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;
                    const lx = tx+dx, ly = topY+dy, lz = tz+dz;
                    if (lx < 0 || lx >= WORLD_SIZE || lz < 0 || lz >= WORLD_SIZE) continue;
                    const lk = `${lx},${ly},${lz}`;
                    if (!world[lk]) world[lk] = 'leaves';
                }
            }
        }
    }

    rebuildMeshes();
}

// Seeded RNG
function mulberry32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

// ============================================
// CHICKENS
// ============================================
function createChickenMesh() {
    const group = new THREE.Group();
    const white = new THREE.MeshLambertMaterial({ color: 0xf2f2f2 });
    const darkWhite = new THREE.MeshLambertMaterial({ color: 0xddddd5 });
    const black = new THREE.MeshLambertMaterial({ color: 0x111111 });
    const red = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
    const yellow = new THREE.MeshLambertMaterial({ color: 0xccaa00 });
    const orange = new THREE.MeshLambertMaterial({ color: 0xe8930a });

    // Body — wide, flat, chunky (Minecraft chicken shape)
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 0.6), white);
    body.position.set(0, 0.35, 0);
    group.add(body);

    // Head — big cube, same width as body looks right in MC
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), white);
    head.position.set(0, 0.65, 0.3);
    group.add(head);

    // Eyes — black dots on each side of head
    const eyeGeo = new THREE.BoxGeometry(0.02, 0.06, 0.06);
    const eyeL = new THREE.Mesh(eyeGeo, black);
    eyeL.position.set(-0.16, 0.68, 0.36);
    group.add(eyeL);
    const eyeR = new THREE.Mesh(eyeGeo, black);
    eyeR.position.set(0.16, 0.68, 0.36);
    group.add(eyeR);

    // Beak — flat orange box sticking out front
    const beak = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.06, 0.12), orange);
    beak.position.set(0, 0.62, 0.48);
    group.add(beak);

    // Comb — red on top of head
    const comb = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.1, 0.14), red);
    comb.position.set(0, 0.84, 0.3);
    group.add(comb);

    // Wattle — red dangling under beak
    const wattle = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.06), red);
    wattle.position.set(0, 0.52, 0.44);
    group.add(wattle);

    // Wings — flat boxes on each side, slightly off-white
    const wingGeo = new THREE.BoxGeometry(0.06, 0.22, 0.4);
    const wingL = new THREE.Mesh(wingGeo, darkWhite);
    wingL.position.set(-0.28, 0.38, -0.02);
    group.add(wingL);
    const wingR = new THREE.Mesh(wingGeo, darkWhite);
    wingR.position.set(0.28, 0.38, -0.02);
    group.add(wingR);

    // Legs — yellow sticks
    const legGeo = new THREE.BoxGeometry(0.06, 0.18, 0.06);
    const legL = new THREE.Mesh(legGeo, yellow);
    legL.position.set(-0.12, 0.09, 0);
    group.add(legL);
    const legR = new THREE.Mesh(legGeo, yellow);
    legR.position.set(0.12, 0.09, 0);
    group.add(legR);

    // Feet — flat yellow pads
    const footGeo = new THREE.BoxGeometry(0.1, 0.03, 0.14);
    const footL = new THREE.Mesh(footGeo, yellow);
    footL.position.set(-0.12, 0.015, 0.03);
    group.add(footL);
    const footR = new THREE.Mesh(footGeo, yellow);
    footR.position.set(0.12, 0.015, 0.03);
    group.add(footR);

    // Tail feathers — sticking up at back
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.2, 0.08), darkWhite);
    tail.position.set(0, 0.55, -0.3);
    tail.rotation.x = -0.3;
    group.add(tail);

    return group;
}

function spawnChicken() {
    // Spawn near the player (within 8-16 blocks)
    const angle = Math.random() * Math.PI * 2;
    const dist = 8 + Math.random() * 8;
    let x = camera.position.x + Math.cos(angle) * dist;
    let z = camera.position.z + Math.sin(angle) * dist;
    // Clamp to world bounds
    x = Math.max(1, Math.min(WORLD_SIZE - 1, x));
    z = Math.max(1, Math.min(WORLD_SIZE - 1, z));
    const mesh = createChickenMesh();
    mesh.scale.set(1.3, 1.3, 1.3); // slightly bigger for visibility
    mesh.position.set(x, 3, z);
    scene.add(mesh);

    chickens.push({
        mesh: mesh,
        x: x, z: z,
        targetX: x, targetZ: z,
        moveTimer: Math.random() * 3, // time until next wander
        idleTimer: 0,
        bobPhase: Math.random() * Math.PI * 2,
        cluckTimer: 2 + Math.random() * 5,
    });
}

function updateChickens(delta) {
    // Respawn if below 2 chickens (keep 2-3 in the world)
    if (chickens.length < 2) {
        spawnChicken();
    }

    // Remove chickens too far from player
    for (let i = chickens.length - 1; i >= 0; i--) {
        const c = chickens[i];
        const dx = c.x - camera.position.x;
        const dz = c.z - camera.position.z;
        if (dx * dx + dz * dz > 40 * 40) {
            scene.remove(c.mesh);
            chickens.splice(i, 1);
        }
    }

    for (const c of chickens) {
        // Wander AI
        c.moveTimer -= delta;
        if (c.moveTimer <= 0) {
            // Pick new random target nearby
            c.targetX = Math.max(1, Math.min(WORLD_SIZE - 1, c.x + (Math.random() - 0.5) * 6));
            c.targetZ = Math.max(1, Math.min(WORLD_SIZE - 1, c.z + (Math.random() - 0.5) * 6));
            c.moveTimer = 2 + Math.random() * 4;
        }

        // Move toward target
        const dx = c.targetX - c.x;
        const dz = c.targetZ - c.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist > 0.1) {
            const speed = 1.2 * delta;
            c.x += (dx / dist) * speed;
            c.z += (dz / dist) * speed;
            // Face movement direction
            c.mesh.rotation.y = Math.atan2(-dx, -dz);
        }

        // Head bobbing while moving
        c.bobPhase += delta * (dist > 0.1 ? 8 : 2);
        const bob = Math.sin(c.bobPhase) * (dist > 0.1 ? 0.04 : 0.015);

        // Find ground height at chicken position
        const bx = Math.floor(c.x), bz = Math.floor(c.z);
        let groundY = 3; // default (top of grass at y=2)
        for (let y = WORLD_HEIGHT + 5; y >= 0; y--) {
            if (world[`${bx},${y},${bz}`]) { groundY = y + 1; break; }
        }

        c.mesh.position.set(c.x, groundY + bob, c.z);
    }
}

// ============================================
// DAY/NIGHT CYCLE
// ============================================
let starsMesh = null;
let sunSprite = null;
let moonSprite = null;

// Separate scene for sky objects (sun, moon, stars) — rendered without fog
const skyScene = new THREE.Scene();
skyScene.background = new THREE.Color(0x87CEEB);
const SKY_DIST = 80; // distance from camera for sky objects

function createStars() {
    const count = 300;
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const rng = mulberry32(999);
    for (let i = 0; i < count; i++) {
        const theta = rng() * Math.PI * 2;
        const phi = rng() * Math.PI * 0.48;
        const r = SKY_DIST;
        positions[i * 3]     = Math.sin(phi) * Math.cos(theta) * r;
        positions[i * 3 + 1] = Math.cos(phi) * r;
        positions[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * r;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, sizeAttenuation: true });
    starsMesh = new THREE.Points(geo, mat);
    starsMesh.visible = false;
    skyScene.add(starsMesh);
}

function createSunSprite() {
    const size = 64;
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const ctx = c.getContext('2d');
    const rng = mulberry32(555);
    const cx = size / 2, cy = size / 2, r = size / 2 - 2;

    // Outer glow
    const glow = ctx.createRadialGradient(cx, cy, r * 0.5, cx, cy, r);
    glow.addColorStop(0, 'rgba(255,240,100,1)');
    glow.addColorStop(0.5, 'rgba(255,200,50,0.6)');
    glow.addColorStop(0.8, 'rgba(255,160,20,0.2)');
    glow.addColorStop(1, 'rgba(255,130,0,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(0, 0, size, size);

    // Pixelated sun disc — bright yellow/orange noisy pixels
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const dx = x - cx, dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < r * 0.55) {
                const v = Math.floor((rng() - 0.5) * 25);
                const pr = Math.min(255, 255 + v);
                const pg = Math.min(255, Math.max(0, 220 + v));
                const pb = Math.max(0, 60 + v);
                ctx.fillStyle = `rgb(${pr},${pg},${pb})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }

    const tex = new THREE.CanvasTexture(c);
    tex.magFilter = THREE.NearestFilter;
    tex.minFilter = THREE.NearestFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    sunSprite = new THREE.Sprite(mat);
    sunSprite.scale.set(12, 12, 1);
    sunSprite.renderOrder = 1;
    skyScene.add(sunSprite);
}

function createMoonSprite() {
    const size = 64;
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const ctx = c.getContext('2d');
    const rng = mulberry32(777);
    const cx = size / 2, cy = size / 2, r = size / 2 - 2;

    // Soft glow
    const glow = ctx.createRadialGradient(cx, cy, r * 0.5, cx, cy, r);
    glow.addColorStop(0, 'rgba(230,235,250,1)');
    glow.addColorStop(0.5, 'rgba(200,210,235,0.4)');
    glow.addColorStop(0.8, 'rgba(170,180,210,0.15)');
    glow.addColorStop(1, 'rgba(150,160,200,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(0, 0, size, size);

    // Pixelated moon disc — bright grey/white pixels
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const dx = x - cx, dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < r * 0.55) {
                const v = Math.floor((rng() - 0.5) * 20);
                const base = 225 + v;
                const pr = Math.min(255, Math.max(0, base - 5));
                const pg = Math.min(255, Math.max(0, base));
                const pb = Math.min(255, Math.max(0, base + 12));
                ctx.fillStyle = `rgb(${pr},${pg},${pb})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }

    // Craters — darker circular patches
    const craters = [
        { x: cx - 6, y: cy - 4, r: 4 },
        { x: cx + 7, y: cy + 3, r: 3 },
        { x: cx + 2, y: cy + 8, r: 5 },
        { x: cx - 8, y: cy + 6, r: 2.5 },
        { x: cx + 5, y: cy - 7, r: 2 },
    ];
    for (const cr of craters) {
        for (let y = Math.floor(cr.y - cr.r); y <= Math.ceil(cr.y + cr.r); y++) {
            for (let x = Math.floor(cr.x - cr.r); x <= Math.ceil(cr.x + cr.r); x++) {
                const dx = x - cr.x, dy = y - cr.y;
                if (dx * dx + dy * dy < cr.r * cr.r) {
                    const v = Math.floor((rng() - 0.5) * 15);
                    ctx.fillStyle = `rgb(${165 + v},${170 + v},${182 + v})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    }

    const tex = new THREE.CanvasTexture(c);
    tex.magFilter = THREE.NearestFilter;
    tex.minFilter = THREE.NearestFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    moonSprite = new THREE.Sprite(mat);
    moonSprite.scale.set(9, 9, 1);
    moonSprite.renderOrder = 1;
    skyScene.add(moonSprite);
}

// Color interpolation helpers
function lerpColor(c1, c2, t) {
    const r1 = (c1 >> 16) & 0xff, g1 = (c1 >> 8) & 0xff, b1 = c1 & 0xff;
    const r2 = (c2 >> 16) & 0xff, g2 = (c2 >> 8) & 0xff, b2 = c2 & 0xff;
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return (r << 16) | (g << 8) | b;
}

// Sky color keyframes
// 0=midnight, 0.25=sunrise, 0.5=noon, 0.75=sunset
const SKY_KEYS = [
    { t: 0.00, sky: 0x0a0a2e, fog: 0x0a0a2e, ambient: 0.15, dir: 0.05, dirColor: 0x8888aa },
    { t: 0.20, sky: 0x1a1a3e, fog: 0x1a1a3e, ambient: 0.2,  dir: 0.1,  dirColor: 0x9999bb },
    { t: 0.25, sky: 0xff7733, fog: 0xff9955, ambient: 0.4,  dir: 0.3,  dirColor: 0xffaa66 },
    { t: 0.30, sky: 0xffaa55, fog: 0xffbb77, ambient: 0.5,  dir: 0.5,  dirColor: 0xffe0a0 },
    { t: 0.35, sky: 0x87CEEB, fog: 0x87CEEB, ambient: 0.6,  dir: 0.8,  dirColor: 0xffffff },
    { t: 0.50, sky: 0x87CEEB, fog: 0x87CEEB, ambient: 0.6,  dir: 0.8,  dirColor: 0xffffff },
    { t: 0.65, sky: 0x87CEEB, fog: 0x87CEEB, ambient: 0.6,  dir: 0.8,  dirColor: 0xffffff },
    { t: 0.70, sky: 0xffaa55, fog: 0xffbb77, ambient: 0.5,  dir: 0.5,  dirColor: 0xffe0a0 },
    { t: 0.75, sky: 0xff6633, fog: 0xff8844, ambient: 0.4,  dir: 0.3,  dirColor: 0xff8844 },
    { t: 0.80, sky: 0x1a1a3e, fog: 0x1a1a3e, ambient: 0.2,  dir: 0.1,  dirColor: 0x9999bb },
    { t: 1.00, sky: 0x0a0a2e, fog: 0x0a0a2e, ambient: 0.15, dir: 0.05, dirColor: 0x8888aa },
];

function updateDayNight(delta) {
    gameTime += delta / DAY_DURATION;
    if (gameTime >= 1) gameTime -= 1;

    // Find the two keyframes we're between
    let k0 = SKY_KEYS[SKY_KEYS.length - 1], k1 = SKY_KEYS[0];
    for (let i = 0; i < SKY_KEYS.length - 1; i++) {
        if (gameTime >= SKY_KEYS[i].t && gameTime < SKY_KEYS[i + 1].t) {
            k0 = SKY_KEYS[i];
            k1 = SKY_KEYS[i + 1];
            break;
        }
    }

    const range = k1.t - k0.t;
    const t = range > 0 ? (gameTime - k0.t) / range : 0;

    const skyColor = lerpColor(k0.sky, k1.sky, t);
    const fogColor = lerpColor(k0.fog, k1.fog, t);
    const dirColor = lerpColor(k0.dirColor, k1.dirColor, t);
    const ambientIntensity = k0.ambient + (k1.ambient - k0.ambient) * t;
    const dirIntensity = k0.dir + (k1.dir - k0.dir) * t;

    skyScene.background.setHex(skyColor);
    scene.fog.color.setHex(fogColor);
    ambientLight.intensity = ambientIntensity;
    dirLight.intensity = dirIntensity;
    dirLight.color.setHex(dirColor);

    // Sun/moon orbit — arc across the sky relative to camera
    // sunAngle: 0.25 (6AM) = east horizon, 0.5 (noon) = zenith, 0.75 (6PM) = west horizon
    const sunAngle = gameTime * Math.PI * 2 - Math.PI / 2;
    const moonAngle = sunAngle + Math.PI;

    // Positions in sky scene (centered on camera, no fog)
    const sunX = Math.cos(sunAngle) * SKY_DIST;
    const sunY = Math.sin(sunAngle) * SKY_DIST;
    const sunZ = 0;

    const moonX = Math.cos(moonAngle) * SKY_DIST;
    const moonY = Math.sin(moonAngle) * SKY_DIST;
    const moonZ = 0;

    // Update directional light to come from the sun direction
    dirLight.position.set(
        camera.position.x + Math.cos(sunAngle) * 30,
        camera.position.y + Math.sin(sunAngle) * 30,
        camera.position.z
    );

    // Position sun sprite — show when above horizon
    if (sunSprite) {
        sunSprite.position.set(sunX, sunY, sunZ);
        sunSprite.visible = sunY > -4;
        if (sunY > -4 && sunY < 8) {
            sunSprite.material.opacity = Math.max(0, Math.min(1, (sunY + 4) / 12));
        } else {
            sunSprite.material.opacity = 1;
        }
    }

    // Position moon sprite
    if (moonSprite) {
        moonSprite.position.set(moonX, moonY, moonZ);
        moonSprite.visible = moonY > -4;
        if (moonY > -4 && moonY < 8) {
            moonSprite.material.opacity = Math.max(0, Math.min(1, (moonY + 4) / 12));
        } else {
            moonSprite.material.opacity = 1;
        }
    }

    // Stars visible at night
    if (starsMesh) {
        const isNight = gameTime < 0.22 || gameTime > 0.78;
        starsMesh.visible = isNight;
        if (isNight) {
            let starAlpha = 1;
            if (gameTime > 0.78) starAlpha = Math.min(1, (gameTime - 0.78) / 0.04);
            else if (gameTime < 0.22) starAlpha = Math.min(1, (0.22 - gameTime) / 0.04);
            starsMesh.material.opacity = starAlpha;
            starsMesh.material.transparent = starAlpha < 1;
        }
    }

    // Update HUD clock
    const totalMinutes = Math.floor(gameTime * 24 * 60);
    const hours = Math.floor(totalMinutes / 60) % 24;
    const minutes = totalMinutes % 60;
    const timeStr = String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
    const isDay = gameTime > 0.25 && gameTime < 0.75;
    const icon = isDay ? '\u2600' : '\u263E';
    document.getElementById('d-time').textContent = icon + ' ' + timeStr;
}

// ============================================
// INVENTORY & HOTBAR
// ============================================
function addToInventory(type, count) {
    // Try to stack in existing hotbar slot
    for (let i = 0; i < 9; i++) {
        if (hotbar[i] && hotbar[i].type === type) {
            hotbar[i].count += count;
            renderHotbar();
            return;
        }
    }
    // Find empty slot
    for (let i = 0; i < 9; i++) {
        if (!hotbar[i]) {
            hotbar[i] = { type, count };
            renderHotbar();
            return;
        }
    }
    // Hotbar full - still track in overflow inventory
    inventory[type] = (inventory[type] || 0) + count;
    showNotif('Hotbar full! Item stored in inventory.');
    renderHotbar();
}

function removeFromHotbar(slot) {
    if (!hotbar[slot]) return false;
    hotbar[slot].count--;
    if (hotbar[slot].count <= 0) hotbar[slot] = null;
    renderHotbar();
    return true;
}

function countItem(type) {
    let c = 0;
    for (let i = 0; i < 9; i++) {
        if (hotbar[i] && hotbar[i].type === type) c += hotbar[i].count;
    }
    c += (inventory[type] || 0);
    return c;
}

function consumeItem(type, amount) {
    let remaining = amount;
    // Take from hotbar first
    for (let i = 0; i < 9; i++) {
        if (remaining <= 0) break;
        if (hotbar[i] && hotbar[i].type === type) {
            const take = Math.min(remaining, hotbar[i].count);
            hotbar[i].count -= take;
            remaining -= take;
            if (hotbar[i].count <= 0) hotbar[i] = null;
        }
    }
    // Then from overflow
    if (remaining > 0 && inventory[type]) {
        const take = Math.min(remaining, inventory[type]);
        inventory[type] -= take;
        remaining -= take;
    }
    renderHotbar();
}

function renderHotbar() {
    const bar = document.getElementById('hotbar');
    bar.innerHTML = '';
    for (let i = 0; i < 9; i++) {
        const slot = document.createElement('div');
        slot.className = 'hotbar-slot' + (i === selectedSlot ? ' selected' : '');
        slot.onclick = () => { selectedSlot = i; renderHotbar(); };

        const keyLabel = document.createElement('div');
        keyLabel.className = 'slot-key';
        keyLabel.textContent = i + 1;
        slot.appendChild(keyLabel);

        if (hotbar[i]) {
            const swatch = document.createElement('div');
            swatch.className = 'slot-color';
            const type = hotbar[i].type;
            // Use canvas texture if available
            const texKey = (type === 'grass') ? 'grass_top' : (type === 'wood') ? 'wood' : type;
            if (blockTextures[texKey] && blockTextures[texKey].image) {
                if (!texDataURLCache[texKey]) texDataURLCache[texKey] = blockTextures[texKey].image.toDataURL();
                swatch.style.background = 'none';
                swatch.style.imageRendering = 'pixelated';
                swatch.style.backgroundImage = `url(${texDataURLCache[texKey]})`;
                swatch.style.backgroundSize = 'cover';
            } else {
                const b = BLOCKS[type];
                swatch.style.background = '#' + (b ? b.color.toString(16).padStart(6, '0') : 'ff00ff');
            }
            slot.appendChild(swatch);

            const cnt = document.createElement('div');
            cnt.className = 'slot-count';
            cnt.textContent = hotbar[i].count;
            slot.appendChild(cnt);
        }
        bar.appendChild(slot);
    }
}

// ============================================
// BLOCK INTERACTION
// ============================================
function getTargetBlock(screenX, screenY) {
    const ndc = (screenX !== undefined && screenY !== undefined)
        ? new THREE.Vector2((screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1)
        : new THREE.Vector2(0, 0);
    raycaster.setFromCamera(ndc, camera);
    const hits = raycaster.intersectObjects(Object.values(instancedMeshes), false);
    if (hits.length === 0) return null;
    const hit = hits[0];
    const blockType = hit.object.userData.blockType;
    const key = instSlots[blockType] && instSlots[blockType][hit.instanceId];
    if (!key) return null;
    const [bx, by, bz] = key.split(',').map(Number);
    return { bx, by, bz, type: blockType, face: hit.face };
}

function mineBlock(screenX, screenY) {
    const hit = getTargetBlock(screenX, screenY);
    if (!hit) return;
    removeBlock(hit.bx, hit.by, hit.bz);
    addToInventory(hit.type, 1);
    saveState();
}

function placeBlock(screenX, screenY) {
    if (!hotbar[selectedSlot]) return;
    const hit = getTargetBlock(screenX, screenY);
    if (!hit) return;

    // Calculate placement position from face normal
    const normal = hit.face.normal;
    const px = hit.bx + Math.round(normal.x);
    const py = hit.by + Math.round(normal.y);
    const pz = hit.bz + Math.round(normal.z);

    // Don't place inside player
    const camX = Math.floor(camera.position.x);
    const camY1 = Math.floor(camera.position.y);
    const camY2 = Math.floor(camera.position.y - 1);
    const camZ = Math.floor(camera.position.z);
    if (px === camX && pz === camZ && (py === camY1 || py === camY2)) return;

    // Don't place outside world bounds
    if (px < 0 || px >= WORLD_SIZE || pz < 0 || pz >= WORLD_SIZE || py < 0 || py >= WORLD_HEIGHT + 10) return;

    const key = `${px},${py},${pz}`;
    if (world[key]) return; // Already occupied

    const type = hotbar[selectedSlot].type;
    // Don't place non-block items
    if (type === 'blogpost' || type === 'paper') return;

    addBlock(px, py, pz, type);
    removeFromHotbar(selectedSlot);
    saveState();
}

// ============================================
// CRAFTING — grid-based, shape matters
// ============================================

// Extract the minimal bounding box of filled slots as a 2D type array.
// Returns null if grid is empty.
function extractGridPattern(grid) {
    let minRow = 3, maxRow = -1, minCol = 3, maxCol = -1;
    for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
            if (grid[r * 3 + c]) {
                minRow = Math.min(minRow, r);
                maxRow = Math.max(maxRow, r);
                minCol = Math.min(minCol, c);
                maxCol = Math.max(maxCol, c);
            }
        }
    }
    if (maxRow === -1) return null;
    const rows = [];
    for (let r = minRow; r <= maxRow; r++) {
        const row = [];
        for (let c = minCol; c <= maxCol; c++) {
            row.push(grid[r * 3 + c] ? grid[r * 3 + c].type : null);
        }
        rows.push(row);
    }
    return rows;
}

function patternsEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let r = 0; r < a.length; r++) {
        if (a[r].length !== b[r].length) return false;
        for (let c = 0; c < a[r].length; c++) {
            if (a[r][c] !== b[r][c]) return false;
        }
    }
    return true;
}

function matchCurrentRecipe() {
    const extracted = extractGridPattern(craftGrid);
    if (!extracted) return null;
    for (const recipe of RECIPES) {
        if (patternsEqual(extracted, recipe.pattern)) return recipe;
        // Check horizontal mirror
        const mirrored = recipe.pattern.map(row => [...row].reverse());
        if (patternsEqual(extracted, mirrored)) return recipe;
    }
    return null;
}

function toggleCraft() {
    craftOpen = !craftOpen;
    document.getElementById('craft-panel').classList.toggle('open', craftOpen);
    if (craftOpen) {
        selectedCraftItem = null;
        renderCraftPanel();
    } else {
        returnGridToInventory();
    }
}

function returnGridToInventory() {
    for (let i = 0; i < 9; i++) {
        if (craftGrid[i]) {
            addToInventory(craftGrid[i].type, craftGrid[i].count);
            craftGrid[i] = null;
        }
    }
}

function clearCraftGrid() {
    returnGridToInventory();
    renderCraftPanel();
}

function handleGridSlotClick(idx) {
    if (selectedCraftItem) {
        // Placing: consume 1 from inventory into this slot
        if (countItem(selectedCraftItem) <= 0) {
            selectedCraftItem = null;
            renderCraftPanel();
            return;
        }
        // If slot already has a different type, return it first
        if (craftGrid[idx] && craftGrid[idx].type !== selectedCraftItem) {
            addToInventory(craftGrid[idx].type, craftGrid[idx].count);
            craftGrid[idx] = null;
        }
        consumeItem(selectedCraftItem, 1);
        if (craftGrid[idx]) {
            craftGrid[idx].count++;
        } else {
            craftGrid[idx] = { type: selectedCraftItem, count: 1 };
        }
    } else if (craftGrid[idx]) {
        // No item selected — click returns the slot to inventory
        addToInventory(craftGrid[idx].type, craftGrid[idx].count);
        craftGrid[idx] = null;
    }
    renderCraftPanel();
}

function handleGridSlotRightClick(e, idx) {
    e.preventDefault();
    if (craftGrid[idx]) {
        addToInventory(craftGrid[idx].type, 1);
        craftGrid[idx].count--;
        if (craftGrid[idx].count <= 0) craftGrid[idx] = null;
        renderCraftPanel();
    }
}

function makeSwatchEl(type, w, h) {
    const swatch = document.createElement('div');
    swatch.className = 'cs-swatch';
    swatch.style.width = w + 'px';
    swatch.style.height = h + 'px';
    const texKey = type === 'grass' ? 'grass_top' : type === 'wood' ? 'wood' : type;
    if (blockTextures[texKey] && blockTextures[texKey].image) {
        if (!texDataURLCache[texKey]) texDataURLCache[texKey] = blockTextures[texKey].image.toDataURL();
        swatch.style.backgroundImage = `url(${texDataURLCache[texKey]})`;
        swatch.style.backgroundSize = 'cover';
    } else {
        const b = BLOCKS[type];
        swatch.style.background = '#' + (b ? b.color.toString(16).padStart(6, '0') : 'ff00ff');
    }
    return swatch;
}

function renderCraftPanel() {
    // --- 3×3 grid ---
    const gridEl = document.getElementById('craft-grid');
    gridEl.innerHTML = '';
    for (let i = 0; i < 9; i++) {
        const slot = document.createElement('div');
        slot.className = 'craft-slot' + (craftGrid[i] ? ' has-item' : '');
        slot.onclick = () => handleGridSlotClick(i);
        slot.oncontextmenu = (e) => handleGridSlotRightClick(e, i);
        if (craftGrid[i]) {
            slot.appendChild(makeSwatchEl(craftGrid[i].type, 34, 34));
            if (craftGrid[i].count > 1) {
                const cnt = document.createElement('div');
                cnt.className = 'cs-count';
                cnt.textContent = craftGrid[i].count;
                slot.appendChild(cnt);
            }
        }
        gridEl.appendChild(slot);
    }

    // --- Output slot ---
    const matched = matchCurrentRecipe();
    const outputSlot = document.getElementById('craft-output-slot');
    const outputName = document.getElementById('craft-output-name');
    const outputInfo = document.getElementById('craft-output-info');
    outputSlot.innerHTML = '';
    outputSlot.className = matched ? 'has-result' : '';

    if (matched) {
        if (matched.output) {
            const sw = makeSwatchEl(matched.output.type, 42, 42);
            outputSlot.appendChild(sw);
            if (matched.output.count > 1) {
                const cnt = document.createElement('div');
                cnt.className = 'cs-count';
                cnt.textContent = matched.output.count;
                outputSlot.appendChild(cnt);
            }
        } else {
            outputSlot.textContent = matched.special === 'publish' ? '📜' : '⛏';
        }
        outputName.textContent = matched.name;
        let infoText = matched.resultText || '';
        if (matched.special === 'pickaxe_stone' && pickaxeLevel >= 1) infoText = 'Already crafted';
        if (matched.special === 'pickaxe_iron' && pickaxeLevel >= 2) infoText = 'Already crafted';
        if (matched.special === 'publish') {
            const mult = 1 + getRankIndex() * 0.5;
            infoText = `+${Math.floor(10*mult)}–${Math.floor(50*mult)} followers`;
        }
        outputInfo.textContent = infoText;
    } else {
        outputName.textContent = '';
        outputInfo.textContent = '';
    }

    // --- Craft button ---
    let canCraft = false;
    if (matched) {
        if (matched.special === 'pickaxe_stone') canCraft = pickaxeLevel < 1;
        else if (matched.special === 'pickaxe_iron') canCraft = pickaxeLevel < 2;
        else canCraft = true;
    }
    document.getElementById('do-craft-btn').disabled = !canCraft;

    // --- Inventory picker ---
    const invList = document.getElementById('craft-inv-list');
    invList.innerHTML = '';
    const allItems = {};
    for (let i = 0; i < 9; i++) {
        if (hotbar[i]) allItems[hotbar[i].type] = (allItems[hotbar[i].type] || 0) + hotbar[i].count;
    }
    for (const [type, count] of Object.entries(inventory)) {
        if (count > 0) allItems[type] = (allItems[type] || 0) + count;
    }
    for (const [type, count] of Object.entries(allItems)) {
        if (!BLOCKS[type]) continue;
        const item = document.createElement('div');
        item.className = 'inv-item' + (selectedCraftItem === type ? ' selected' : '');
        item.onclick = () => {
            selectedCraftItem = selectedCraftItem === type ? null : type;
            renderCraftPanel();
        };
        const sw = document.createElement('div');
        sw.className = 'inv-swatch';
        const texKey = type === 'grass' ? 'grass_top' : type === 'wood' ? 'wood' : type;
        if (blockTextures[texKey] && blockTextures[texKey].image) {
            sw.style.backgroundImage = `url(${blockTextures[texKey].image.toDataURL()})`;
            sw.style.backgroundSize = 'cover';
            sw.style.width = '28px'; sw.style.height = '28px';
            sw.style.imageRendering = 'pixelated';
        } else {
            const b = BLOCKS[type];
            sw.style.background = '#' + (b ? b.color.toString(16).padStart(6, '0') : 'ff00ff');
            sw.style.width = '28px'; sw.style.height = '28px'; sw.style.borderRadius = '2px';
        }
        item.appendChild(sw);
        const cnt = document.createElement('div');
        cnt.className = 'inv-count';
        cnt.textContent = count;
        item.appendChild(cnt);
        invList.appendChild(item);
    }
}

function doCraft() {
    const matched = matchCurrentRecipe();
    if (!matched) return;
    if (matched.special === 'pickaxe_stone' && pickaxeLevel >= 1) return;
    if (matched.special === 'pickaxe_iron' && pickaxeLevel >= 2) return;

    // Items were consumed when placed into the grid — just clear it
    for (let i = 0; i < 9; i++) craftGrid[i] = null;
    selectedCraftItem = null;

    if (matched.special === 'pickaxe_stone') {
        pickaxeLevel = Math.max(pickaxeLevel, 1);
        showNotif('Stone Pickaxe equipped! Mining is faster.');
    } else if (matched.special === 'pickaxe_iron') {
        pickaxeLevel = Math.max(pickaxeLevel, 2);
        showNotif('Iron Pickaxe equipped! Mining is much faster.');
    } else if (matched.special === 'publish') {
        const rank = getRankIndex();
        const mult = 1 + rank * 0.5;
        const gained = Math.floor((10 + Math.random() * 40) * mult);
        const coins = Math.floor(2 + Math.random() * 8 * mult);
        followers += gained;
        currentUser.coins = (currentUser.coins || 0) + coins;
        localStorage.setItem('user', JSON.stringify(currentUser));
        syncCoins();
        updateHUD();
        showNotif(`Published! +${gained} followers, +${coins} coins`);
    } else {
        addToInventory(matched.output.type, matched.output.count);
        showNotif(`Crafted ${matched.output.count}× ${matched.name}!`);
    }

    saveState();
    renderCraftPanel();
}

function getRankIndex() {
    for (let i = RANKS.length - 1; i >= 0; i--) {
        if (followers >= RANKS[i].followers) return i;
    }
    return 0;
}

// ============================================
// HUD
// ============================================
function updateHUD() {
    document.getElementById('d-coins').textContent = currentUser.coins || 0;
    document.getElementById('d-followers').textContent = followers;
    document.getElementById('d-rank').textContent = RANKS[getRankIndex()].name;
}

function showNotif(text) {
    const el = document.createElement('div');
    el.className = 'notif';
    el.textContent = text;
    document.body.appendChild(el);
    setTimeout(() => { el.style.opacity = '0'; el.style.transition = 'opacity 0.5s'; }, 2000);
    setTimeout(() => el.remove(), 2500);
}

function syncCoins() {
    fetch(API_URL + '/user/coins', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + authToken },
        body: JSON.stringify({ coins: currentUser.coins }),
    }).catch(() => {});
}

// ============================================
// SAVE / LOAD
// ============================================
function saveState() {
    const s = {
        world: world,
        hotbar: hotbar,
        inventory: inventory,
        followers: followers,
        pickaxeLevel: pickaxeLevel,
        camPos: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
        camRot: { x: euler.x, y: euler.y },
        gameTime: gameTime,
    };
    localStorage.setItem('blogcraft3d', JSON.stringify(s));
}

function loadState() {
    const raw = localStorage.getItem('blogcraft3d');
    if (!raw) return false;
    const s = JSON.parse(raw);

    world = {};
    // Restore world data then build instanced meshes in one pass
    for (const [key, type] of Object.entries(s.world)) world[key] = type;
    rebuildMeshes();

    hotbar = s.hotbar || [null,null,null,null,null,null,null,null,null];
    inventory = s.inventory || {};
    followers = s.followers || 0;
    pickaxeLevel = s.pickaxeLevel || 0;
    if (s.gameTime !== undefined) gameTime = s.gameTime;

    if (s.camPos) camera.position.set(s.camPos.x, s.camPos.y, s.camPos.z);
    if (s.camRot) {
        euler.x = 0; // always start looking horizontal — avoids loading into an extreme up/down angle
        euler.y = s.camRot.y || 0;
        camera.quaternion.setFromEuler(euler);
    }

    return true;
}

// ============================================
// PHYSICS / MOVEMENT
// ============================================
function getBlock(x, y, z) {
    return world[`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`];
}

function isColliding(px, py, pz) {
    // Check player bounding box (0.3 radius, 1.7 height)
    const r = 0.3;
    for (let dx = -r; dx <= r; dx += r * 2) {
        for (let dz = -r; dz <= r; dz += r * 2) {
            for (let dy = 0; dy < playerHeight; dy += 0.8) {
                if (getBlock(px + dx, py - playerHeight + dy, pz + dz)) return true;
            }
        }
    }
    return false;
}

function updatePhysics(delta) {
    if (craftOpen) return;

    // Gravity
    velocity.y -= 20 * delta;

    // Movement direction
    const direction = new THREE.Vector3();
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

    isSprinting = moveForward && moveBackward; // S + W = sprint
    document.getElementById('sprint-indicator').style.display = isSprinting ? 'block' : 'none';
    const speed = isSprinting ? 10 : 5;
    if (moveForward) direction.add(forward);
    if (moveBackward && !isSprinting) direction.sub(forward);
    if (moveRight) direction.add(right);
    if (moveLeft) direction.sub(right);

    if (direction.length() > 0) direction.normalize();
    direction.multiplyScalar(speed * delta);

    // Try X movement
    const newX = camera.position.x + direction.x;
    if (!isColliding(newX, camera.position.y, camera.position.z)) {
        camera.position.x = newX;
    }

    // Try Z movement
    const newZ = camera.position.z + direction.z;
    if (!isColliding(camera.position.x, camera.position.y, newZ)) {
        camera.position.z = newZ;
    }

    // Y movement (gravity + jump)
    const newY = camera.position.y + velocity.y * delta;
    if (!isColliding(camera.position.x, newY, camera.position.z)) {
        camera.position.y = newY;
        canJump = false;
    } else {
        if (velocity.y < 0) canJump = true;
        velocity.y = 0;
    }

    // Floor clamp
    if (camera.position.y < playerHeight + 0.1) {
        camera.position.y = playerHeight + 0.1;
        canJump = true;
        velocity.y = 0;
    }

    // World bounds
    camera.position.x = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, camera.position.x));
    camera.position.z = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, camera.position.z));
}

// ============================================
// CONTROLS - KEYBOARD
// ============================================
document.addEventListener('keydown', (e) => {
    if (craftOpen) {
        if (e.code === 'KeyE' || e.code === 'Escape') toggleCraft();
        return;
    }
    switch (e.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space':
            e.preventDefault();
            if (canJump) { velocity.y = 8; canJump = false; }
            break;
        case 'KeyE': toggleCraft(); break;
        case 'Escape':
            if (craftOpen) toggleCraft();
            break;
        case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4': case 'Digit5':
        case 'Digit6': case 'Digit7': case 'Digit8': case 'Digit9':
            selectedSlot = parseInt(e.code.replace('Digit', '')) - 1;
            renderHotbar();
            break;
    }
});

document.addEventListener('keyup', (e) => {
    switch (e.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyD': moveRight = false; break;
    }
});

// ============================================
// CONTROLS - MOUSE (POINTER LOCK)
// ============================================
const canvas = renderer.domElement;

document.getElementById('start-overlay').addEventListener('click', () => {
    document.getElementById('start-overlay').classList.add('hidden');
    try { canvas.requestPointerLock(); } catch(e) {}
});

canvas.addEventListener('click', () => {
    if (!isPointerLocked) {
        try { canvas.requestPointerLock(); } catch(e) {}
    }
});

let lockTimestamp = 0; // time pointer lock was acquired

document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === canvas;
    // Record the time so we can ignore all spurious deltas for the first 150ms —
    // browsers deliver accumulated mouse movement as a burst of events right after lock
    if (isPointerLocked) lockTimestamp = performance.now();
    document.getElementById('start-overlay').classList.toggle('hidden', isPointerLocked);
});

document.addEventListener('mousemove', (e) => {
    if (!isPointerLocked) return;
    // Discard the initial burst of spurious events after pointer lock is acquired
    if (performance.now() - lockTimestamp < 150) return;
    const sensitivity = 0.002;
    // Clamp per-event delta — tight cap prevents a single fast swipe from slamming
    // the camera into the pitch floor/ceiling
    const dx = Math.max(-30, Math.min(30, e.movementX));
    const dy = Math.max(-30, Math.min(30, e.movementY));
    euler.y -= dx * sensitivity;
    euler.x -= dy * sensitivity;
    euler.x = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, euler.x));
    camera.quaternion.setFromEuler(euler);
});

// Mining / Placing
let mineStartTime = 0;

function stopMining() {
    isMining = false;
    mineTargetKey = null;
    hideCrackOverlay();
    document.getElementById('mine-progress').style.display = 'none';
    document.getElementById('mine-progress-fill').style.width = '0%';
}

canvas.addEventListener('mousedown', (e) => {
    if (!isPointerLocked) return;
    e.preventDefault();
    if (craftOpen) return;

    if (e.button === 0) {
        // Left click - start mining
        isMining = true;
        mineStartTime = performance.now();
        mineScreenX = undefined;
        mineScreenY = undefined;
        mineTargetKey = null;
        document.getElementById('mine-progress').style.display = 'block';
    } else if (e.button === 2) {
        // Right click - place
        placeBlock();
    }
});

canvas.addEventListener('mouseup', (e) => {
    if (e.button === 0) {
        stopMining();
    }
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// ============================================
// CONTROLS - TOUCH (MOBILE)
// ============================================
let touchJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
let touchLook = { active: false, id: null, lastX: 0, lastY: 0 };

const joystickArea = document.getElementById('joystick-area');
const joystickKnob = document.getElementById('joystick-knob');

if (joystickArea) {
    joystickArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const t = e.changedTouches[0];
        touchJoystick.active = true;
        touchJoystick.startX = t.clientX;
        touchJoystick.startY = t.clientY;
        touchJoystick.id = t.identifier;
        // Hide start overlay on mobile
        document.getElementById('start-overlay').classList.add('hidden');
    });

    joystickArea.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (const t of e.changedTouches) {
            if (t.identifier === touchJoystick.id) {
                const dx = t.clientX - touchJoystick.startX;
                const dy = t.clientY - touchJoystick.startY;
                const maxDist = 40;
                const dist = Math.min(Math.sqrt(dx * dx + dy * dy), maxDist);
                const angle = Math.atan2(dy, dx);
                touchJoystick.dx = Math.cos(angle) * dist / maxDist;
                touchJoystick.dy = Math.sin(angle) * dist / maxDist;
                joystickKnob.style.transform = `translate(${-50 + touchJoystick.dx * 40}%, ${-50 + touchJoystick.dy * 40}%)`;
            }
        }
    });

    joystickArea.addEventListener('touchend', (e) => {
        for (const t of e.changedTouches) {
            if (t.identifier === touchJoystick.id) {
                touchJoystick.active = false;
                touchJoystick.dx = 0;
                touchJoystick.dy = 0;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }
        }
    });
}

// Touch look + tap to build / hold to mine
let touchHoldTimer = null;
const HOLD_DURATION = 400; // ms to count as hold (mine)

canvas.addEventListener('touchstart', (e) => {
    document.getElementById('start-overlay').classList.add('hidden');
    for (const t of e.changedTouches) {
        if (t.clientX > window.innerWidth / 3) {
            touchLook.active = true;
            touchLook.id = t.identifier;
            touchLook.startX = t.clientX;
            touchLook.startY = t.clientY;
            touchLook.lastX = t.clientX;
            touchLook.lastY = t.clientY;
            touchLook.moved = false;
            touchLook.held = false;

            // Start hold timer for mining (progressive)
            clearTimeout(touchHoldTimer);
            touchHoldTimer = setTimeout(() => {
                if (!touchLook.moved) {
                    touchLook.held = true;
                    // Start progressive mining (cracks + progress bar)
                    isMining = true;
                    mineStartTime = performance.now();
                    mineScreenX = touchLook.startX;
                    mineScreenY = touchLook.startY;
                    mineTargetKey = null;
                }
            }, HOLD_DURATION);
        }
    }
});

canvas.addEventListener('touchmove', (e) => {
    // When pointer lock is active the user is on a desktop — ignore all touch events
    // so they don't interfere with mouse look (touchpad fires both mousemove AND touchmove)
    if (isPointerLocked) return;
    for (const t of e.changedTouches) {
        if (t.identifier === touchLook.id) {
            const dx = t.clientX - touchLook.lastX;
            const dy = t.clientY - touchLook.lastY;
            const totalDx = t.clientX - touchLook.startX;
            const totalDy = t.clientY - touchLook.startY;
            if (Math.abs(totalDx) > 8 || Math.abs(totalDy) > 8) {
                touchLook.moved = true;
                clearTimeout(touchHoldTimer);
                if (isMining) stopMining();
            }
            euler.y -= dx * 0.005;
            euler.x -= dy * 0.005;
            euler.x = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, euler.x));
            camera.quaternion.setFromEuler(euler);
            touchLook.lastX = t.clientX;
            touchLook.lastY = t.clientY;
        }
    }
});

canvas.addEventListener('touchend', (e) => {
    for (const t of e.changedTouches) {
        if (t.identifier === touchLook.id) {
            touchLook.active = false;
            clearTimeout(touchHoldTimer);
            // Cancel mining if active
            if (isMining) stopMining();
            // Quick tap (not dragged, not held) = place block
            if (!touchLook.moved && !touchLook.held) {
                placeBlock(t.clientX, t.clientY);
            }
        }
    }
});

// Mobile buttons
const btnJump = document.getElementById('btn-jump');
const btnCraft = document.getElementById('btn-craft');

if (btnJump) btnJump.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (canJump) { velocity.y = 8; canJump = false; }
});
if (btnCraft) btnCraft.addEventListener('touchstart', (e) => {
    e.preventDefault();
    toggleCraft();
});

// ============================================
// GAME LOOP
// ============================================
const clock = new THREE.Clock();
let saveTimer = 0;

function animate() {
    requestAnimationFrame(animate);
    const delta = Math.min(clock.getDelta(), 0.1);

    // Mobile joystick movement
    if (isTouchDevice) {
        if (touchJoystick.active) {
            moveForward = touchJoystick.dy < -0.3;
            moveBackward = touchJoystick.dy > 0.3;
            moveLeft = touchJoystick.dx < -0.3;
            moveRight = touchJoystick.dx > 0.3;
        } else {
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
        }
    }

    updatePhysics(delta);
    updateChickens(delta);
    updateDayNight(delta);

    // Mining progress (hold to mine - desktop & mobile)
    if (isMining && !craftOpen) {
        const hit = getTargetBlock(mineScreenX, mineScreenY);
        const targetKey = hit ? `${hit.bx},${hit.by},${hit.bz}` : null;

        // If target changed (looked away), reset mining progress
        if (targetKey !== mineTargetKey) {
            mineTargetKey = targetKey;
            mineStartTime = performance.now();
        }

        if (hit) {
            const elapsed = performance.now() - mineStartTime;
            const duration = miningDuration / (1 + pickaxeLevel * 0.5);
            const pct = Math.min(elapsed / duration, 1);

            document.getElementById('mine-progress').style.display = 'block';
            document.getElementById('mine-progress-fill').style.width = (pct * 100) + '%';
            showCrackOverlay(hit.bx, hit.by, hit.bz, pct);

            if (pct >= 1) {
                mineBlock(mineScreenX, mineScreenY);
                mineStartTime = performance.now();
                mineTargetKey = null;
                hideCrackOverlay();
            }
        } else {
            hideCrackOverlay();
            document.getElementById('mine-progress').style.display = 'none';
            document.getElementById('mine-progress-fill').style.width = '0%';
        }
    }

    // Auto-save
    saveTimer += delta;
    if (saveTimer > 30) {
        saveTimer = 0;
        saveState();
    }

    // Animate right hand
    const isWalking = moveForward || moveBackward || moveLeft || moveRight;
    handBobPhase += delta * (isWalking ? 6 : 1.5);
    const bob = Math.sin(handBobPhase) * (isWalking ? 0.04 : 0.01);
    if (isMining) {
        const swing = Math.sin(performance.now() * 0.008) * 0.5 + 0.5;
        handGroup.position.set(
            handRestPos.x - swing * 0.1,
            handRestPos.y - swing * 0.12,
            handRestPos.z + swing * 0.15
        );
        handGroup.rotation.set(
            handRestRot.x + swing * 0.6,
            handRestRot.y,
            handRestRot.z - swing * 0.2
        );
    } else {
        handGroup.position.set(handRestPos.x, handRestPos.y + bob, handRestPos.z);
        handGroup.rotation.set(handRestRot.x, handRestRot.y, handRestRot.z);
    }

    // Render sky scene first (sun, moon, stars) — no fog, camera rotation only
    skyCamera.quaternion.copy(camera.quaternion);
    renderer.render(skyScene, skyCamera);

    // Render main scene on top (keeps sky behind world geometry)
    renderer.autoClear = false;
    renderer.render(scene, camera);

    // Render hand overlay on top (clear depth only, keep color)
    renderer.clearDepth();
    renderer.render(handScene, handCamera);
    renderer.autoClear = true;
}

// ============================================
// RESIZE
// ============================================
window.addEventListener('resize', () => {
    const aspect = window.innerWidth / window.innerHeight;
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    skyCamera.aspect = aspect;
    skyCamera.updateProjectionMatrix();
    handCamera.aspect = aspect;
    handCamera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============================================
// INIT
// ============================================
function init() {
    checkAuth();
    genTextures();
    initInstanced();
    genCrackTextures();
    createStars();
    createSunSprite();
    createMoonSprite();
    const loaded = loadState();
    if (!loaded) generateWorld();
    // Also clear old tab-based state
    localStorage.removeItem('blogcraft_state');
    renderHotbar();
    updateHUD();
    // Spawn initial chickens nearby
    for (let i = 0; i < 3; i++) spawnChicken();
    animate();
}

init();
</script>
</body>
</html>



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BlogCraft</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        canvas { display: block; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; right: 0;
            pointer-events: none; z-index: 100;
        }
        #hud-top {
            display: flex; justify-content: space-between; padding: 8px 12px;
            background: rgba(0,0,0,0.5);
        }
        #hud-left { color: #fff; font-size: 13px; }
        #hud-left .val { font-weight: bold; }
        .hud-username { color: gold; }
        .hud-coins { color: lime; margin-left: 10px; }
        .hud-followers { color: #e94560; margin-left: 10px; }
        .hud-rank { color: #9c27b0; margin-left: 10px; }
        #hud-right { pointer-events: auto; }
        #hud-right a {
            color: #aaa; font-size: 13px; text-decoration: none; margin-left: 10px; cursor: pointer;
        }
        #hud-right a:hover { color: #fff; }

        /* Crosshair */
        #crosshair {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font-size: 24px; z-index: 101;
            pointer-events: none; text-shadow: 1px 1px 2px #000;
        }

        /* Hotbar */
        #hotbar {
            position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 3px; z-index: 100;
            background: rgba(0,0,0,0.6); padding: 4px; border-radius: 6px;
        }
        .hotbar-slot {
            width: 48px; height: 48px;
            border: 2px solid #555; border-radius: 4px;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; position: relative;
            background: rgba(0,0,0,0.4);
        }
        .hotbar-slot.selected { border-color: gold; background: rgba(255,215,0,0.15); }
        .hotbar-slot .slot-color {
            width: 24px; height: 24px; border-radius: 3px;
            image-rendering: pixelated;
        }
        .hotbar-slot .slot-count {
            position: absolute; bottom: 1px; right: 3px;
            font-size: 10px; color: #fff; font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }
        .hotbar-slot .slot-key {
            position: absolute; top: 1px; left: 3px;
            font-size: 9px; color: #888;
        }

        /* Click to play overlay */
        #start-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7); z-index: 200;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #fff; cursor: pointer;
        }
        #start-overlay h1 { color: gold; font-size: 36px; margin-bottom: 10px; }
        #start-overlay p { font-size: 16px; color: #aaa; margin: 4px; }
        #start-overlay .controls-help {
            margin-top: 20px; font-size: 13px; color: #888;
            text-align: center; line-height: 1.8;
        }
        #start-overlay.hidden { display: none; }

        /* Crafting Panel */
        #craft-panel {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,40,0.95);
            border: 2px solid #555; border-radius: 10px;
            padding: 20px; z-index: 150;
            min-width: 320px; max-height: 80vh; overflow-y: auto;
            display: none;
        }
        #craft-panel.open { display: block; }
        #craft-panel h2 { color: gold; text-align: center; margin-bottom: 12px; font-size: 18px; }
        .recipe {
            background: rgba(255,255,255,0.05);
            border: 1px solid #444; border-radius: 6px;
            padding: 10px; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .recipe-info { flex: 1; }
        .recipe-name { font-weight: bold; color: #fff; font-size: 13px; }
        .recipe-mats { font-size: 12px; color: #aaa; margin-top: 3px; }
        .recipe-mats .has { color: lime; }
        .recipe-mats .miss { color: #e94560; }
        .recipe-result { font-size: 11px; color: #9c27b0; margin-top: 3px; }
        .craft-btn {
            padding: 6px 14px; border: none; border-radius: 5px;
            font-size: 12px; font-weight: bold; cursor: pointer;
            background: #4CAF50; color: #fff; margin-left: 10px;
        }
        .craft-btn:disabled { background: #555; cursor: default; }
        .recipe.selected-recipe { border-color: gold; background: rgba(255,215,0,0.1); }
        #craft-close {
            display: block; margin: 10px auto 0; padding: 8px 20px;
            background: #e94560; color: #fff; border: none; border-radius: 5px;
            font-size: 14px; cursor: pointer;
        }

        /* Notification */
        .notif {
            position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); color: #fff; padding: 8px 16px;
            border-radius: 6px; font-size: 14px; z-index: 200;
            border-left: 3px solid gold;
            animation: notifIn 0.3s ease;
        }
        @keyframes notifIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

        /* Mining progress */
        #mine-progress {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, 20px);
            width: 60px; height: 5px; background: #333; border-radius: 3px;
            overflow: hidden; z-index: 101; display: none;
        }
        #mine-progress-fill { height: 100%; background: gold; width: 0%; }

        /* Mobile controls */
        #mobile-controls { display: none; position: fixed; z-index: 110; }
        #joystick-area {
            position: fixed; bottom: 20px; left: 20px;
            width: 120px; height: 120px;
            background: rgba(255,255,255,0.1); border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
        }
        #joystick-knob {
            width: 40px; height: 40px; background: rgba(255,255,255,0.4);
            border-radius: 50%; position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .mobile-btn {
            position: fixed; width: 50px; height: 50px;
            background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; color: #fff; font-size: 12px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
        }
        #btn-jump { bottom: 80px; right: 20px; }
        #btn-place { bottom: 140px; right: 20px; }
        #btn-craft { bottom: 80px; right: 80px; }

        /* Mobile: shown via JS class on body */
        body.is-touch #mobile-controls { display: block; }
        body.is-touch .hotbar-slot { width: 38px; height: 38px; }
        body.is-touch .hotbar-slot .slot-color { width: 18px; height: 18px; }
        body.is-touch #hotbar { bottom: 70px; }
        body.is-touch #crosshair { display: none; }
        body.is-touch .controls-help-desktop { display: none; }
        body:not(.is-touch) .controls-help-mobile { display: none; }
    </style>
</head>
<body>

<!-- Start Overlay -->
<div id="start-overlay">
    <h1>BlogCraft</h1>
    <p>A 3D voxel world of mining, crafting & blogging</p>
    <p style="color:gold; margin-top:15px;" id="start-action">Click to Play</p>
    <div class="controls-help controls-help-desktop">
        WASD - Move | Mouse - Look | Space - Jump<br>
        Left Click - Mine | Right Click - Place<br>
        1-9 - Select Slot | E - Crafting
    </div>
    <div class="controls-help controls-help-mobile">
        Left Joystick - Move | Right Side - Look<br>
        Tap - Mine | Place Button - Place Block<br>
        Tap Hotbar - Select Slot | E Button - Crafting
    </div>
</div>

<!-- HUD -->
<div id="hud">
    <div id="hud-top">
        <div id="hud-left">
            <span class="hud-username val" id="d-name"></span>
            <span class="hud-coins">Coins: <span class="val" id="d-coins">0</span></span>
            <span class="hud-followers">Followers: <span class="val" id="d-followers">0</span></span>
            <span class="hud-rank">Rank: <span class="val" id="d-rank">Newbie</span></span>
        </div>
        <div id="hud-right">
            <a href="/games/01/home.html">Home</a>
            <a onclick="handleLogout()">Logout</a>
        </div>
    </div>
</div>

<!-- Crosshair -->
<div id="crosshair">+</div>

<!-- Mining progress -->
<div id="mine-progress"><div id="mine-progress-fill"></div></div>

<!-- Hotbar -->
<div id="hotbar"></div>

<!-- Crafting Panel -->
<div id="craft-panel">
    <h2>Crafting</h2>
    <div id="recipe-list"></div>
    <button id="craft-close" onclick="toggleCraft()">Close (E)</button>
</div>

<!-- Mobile Controls -->
<div id="mobile-controls">
    <div id="joystick-area"><div id="joystick-knob"></div></div>
    <div class="mobile-btn" id="btn-jump">Jump</div>
    <div class="mobile-btn" id="btn-place">Place</div>
    <div class="mobile-btn" id="btn-craft">E</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================
// DEVICE DETECTION
// ============================================
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
if (isTouchDevice) {
    document.body.classList.add('is-touch');
    document.getElementById('start-action').textContent = 'Tap to Play';
}

// ============================================
// AUTH
// ============================================
const API_URL = '/games/01/api';
let currentUser = null, authToken = null;

function checkAuth() {
    const u = localStorage.getItem('user'), t = localStorage.getItem('token');
    if (!u || !t) { window.location.href = '/games/01/login.html'; return; }
    currentUser = JSON.parse(u);
    authToken = t;
    document.getElementById('d-name').textContent = currentUser.name;
    document.getElementById('d-coins').textContent = currentUser.coins || 0;
}

function handleLogout() {
    localStorage.removeItem('user');
    localStorage.removeItem('token');
    window.location.href = '/games/01/login.html';
}

// ============================================
// BLOCK TYPES
// ============================================
const BLOCKS = {
    grass:   { name: 'Grass',   color: 0x4CAF50, topColor: 0x66BB6A, sideColor: 0x795548 },
    dirt:    { name: 'Dirt',    color: 0x795548 },
    stone:   { name: 'Stone',   color: 0x9E9E9E },
    wood:    { name: 'Wood',    color: 0x5D4037 },
    leaves:  { name: 'Leaves',  color: 0x2E7D32 },
    iron:    { name: 'Iron',    color: 0xB0BEC5 },
    gold:    { name: 'Gold',    color: 0xFFD700 },
    crystal: { name: 'Crystal', color: 0x00BCD4 },
    planks:  { name: 'Planks',  color: 0xD7A86E },
    paper:   { name: 'Paper',   color: 0xF5F5DC },
    blogpost:{ name: 'Blog Post', color: 0xE91E63 },
};

// ============================================
// RECIPES
// ============================================
const RECIPES = [
    { name: 'Planks', inputs: { wood: 4 }, outputs: { planks: 8 } },
    { name: 'Paper', inputs: { planks: 3 }, outputs: { paper: 6 } },
    { name: 'Blog Post', inputs: { paper: 1, leaves: 1 }, outputs: { blogpost: 1 } },
    { name: 'Stone Pickaxe', inputs: { stone: 3, wood: 2 }, outputs: { _pickaxe_stone: 1 }, special: 'pickaxe_stone' },
    { name: 'Iron Pickaxe', inputs: { iron: 3, wood: 2 }, outputs: { _pickaxe_iron: 1 }, special: 'pickaxe_iron' },
    { name: 'Publish Blog Post', inputs: { blogpost: 1 }, outputs: {}, special: 'publish' },
];

// ============================================
// RANKS
// ============================================
const RANKS = [
    { name: 'Newbie', followers: 0 },
    { name: 'Hobbyist', followers: 50 },
    { name: 'Writer', followers: 200 },
    { name: 'Journalist', followers: 500 },
    { name: 'Influencer', followers: 2000 },
    { name: 'Legend', followers: 10000 },
];

// ============================================
// GAME STATE
// ============================================
const WORLD_SIZE = 32;
const WORLD_HEIGHT = 8;
let world = {}; // key: "x,y,z" -> blockType string
let blockMeshes = {}; // key: "x,y,z" -> THREE.Mesh

let inventory = {}; // blockType -> count
let hotbar = [null,null,null,null,null,null,null,null,null]; // each: {type, count} or null
let selectedSlot = 0;
let followers = 0;
let pickaxeLevel = 0; // 0=hand, 1=stone, 2=iron
let craftOpen = false;
let selectedRecipe = 0;
let placeMode = false;

// Movement state
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let canJump = true;
let velocity = new THREE.Vector3();
let playerHeight = 1.7;
let isPointerLocked = false;

// Mining state
let miningTarget = null, miningTime = 0, miningDuration = 500;

// ============================================
// THREE.JS SETUP
// ============================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 30, 60);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(WORLD_SIZE / 2, 5, WORLD_SIZE / 2);

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(20, 30, 10);
scene.add(dirLight);

// Raycaster for block interaction
const raycaster = new THREE.Raycaster();
raycaster.far = 6;

// Euler for camera rotation
let euler = new THREE.Euler(0, 0, 0, 'YXZ');

// ============================================
// WORLD GENERATION
// ============================================
// Block geometry (shared)
const blockGeo = new THREE.BoxGeometry(1, 1, 1);

// ---- Pixel texture generator ----
const TEX_SIZE = 16;

function makeTexture(drawFn) {
    const c = document.createElement('canvas');
    c.width = TEX_SIZE; c.height = TEX_SIZE;
    const ctx = c.getContext('2d');
    drawFn(ctx);
    const tex = new THREE.CanvasTexture(c);
    tex.magFilter = THREE.NearestFilter;
    tex.minFilter = THREE.NearestFilter;
    return tex;
}

function hexToRgb(hex) {
    return [(hex >> 16) & 0xff, (hex >> 8) & 0xff, hex & 0xff];
}

function varyColor(r, g, b, amount, rng) {
    const v = Math.floor((rng() - 0.5) * amount * 2);
    return `rgb(${Math.max(0,Math.min(255,r+v))},${Math.max(0,Math.min(255,g+v))},${Math.max(0,Math.min(255,b+v))})`;
}

function fillPixelNoise(ctx, baseHex, variance, rng) {
    const [r, g, b] = hexToRgb(baseHex);
    for (let y = 0; y < TEX_SIZE; y++) {
        for (let x = 0; x < TEX_SIZE; x++) {
            ctx.fillStyle = varyColor(r, g, b, variance, rng);
            ctx.fillRect(x, y, 1, 1);
        }
    }
}

// Pre-generate textures for each block type
const blockTextures = {};

function genTextures() {
    const rng = mulberry32(123);

    // Grass top - 4 shades of green (darker)
    blockTextures.grass_top = makeTexture(ctx => {
        const greens = [0x357A38, 0x4E8C51, 0x2E6B30, 0x3A7D3E];
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const base = greens[Math.floor(rng() * greens.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 12, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Grass side - dirt with green top strip
    blockTextures.grass_side = makeTexture(ctx => {
        // Dirt body
        fillPixelNoise(ctx, 0x795548, 15, rng);
        // Green top 3 pixels with jagged edge
        const greens = [0x357A38, 0x4E8C51, 0x2E6B30, 0x3A7D3E];
        for (let x = 0; x < TEX_SIZE; x++) {
            const depth = 2 + Math.floor(rng() * 2);
            for (let y = 0; y < depth; y++) {
                const base = greens[Math.floor(rng() * greens.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 10, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Dirt
    blockTextures.dirt = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x795548, 18, rng);
        // Occasional darker spots
        for (let i = 0; i < 8; i++) {
            ctx.fillStyle = varyColor(90, 60, 40, 10, rng);
            ctx.fillRect(Math.floor(rng()*TEX_SIZE), Math.floor(rng()*TEX_SIZE), 1, 1);
        }
    });

    // Stone
    blockTextures.stone = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x9E9E9E, 20, rng);
        // Cracks / darker lines
        for (let i = 0; i < 5; i++) {
            ctx.fillStyle = varyColor(100, 100, 100, 15, rng);
            const sx = Math.floor(rng()*TEX_SIZE);
            const sy = Math.floor(rng()*TEX_SIZE);
            ctx.fillRect(sx, sy, 1 + Math.floor(rng()*3), 1);
        }
    });

    // Wood - vertical grain
    blockTextures.wood = makeTexture(ctx => {
        const browns = [0x5D4037, 0x4E342E, 0x6D4C41, 0x795548];
        for (let x = 0; x < TEX_SIZE; x++) {
            const base = browns[x % browns.length];
            for (let y = 0; y < TEX_SIZE; y++) {
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 10, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Wood top - rings
    blockTextures.wood_top = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x6D4C41, 12, rng);
        // Simple ring pattern
        const cx = 8, cy = 8;
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const dist = Math.sqrt((x-cx)*(x-cx)+(y-cy)*(y-cy));
                if (Math.floor(dist) % 3 === 0) {
                    ctx.fillStyle = varyColor(70, 50, 30, 8, rng);
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    });

    // Leaves - scattered light/dark greens
    blockTextures.leaves = makeTexture(ctx => {
        const greens = [0x2E7D32, 0x1B5E20, 0x388E3C, 0x256D27];
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const base = greens[Math.floor(rng() * greens.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 15, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
        // Gaps (transparency effect via darker pixels)
        for (let i = 0; i < 12; i++) {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(Math.floor(rng()*TEX_SIZE), Math.floor(rng()*TEX_SIZE), 1, 1);
        }
    });

    // Iron ore - stone with silver flecks
    blockTextures.iron = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x9E9E9E, 15, rng);
        for (let i = 0; i < 10; i++) {
            ctx.fillStyle = varyColor(190, 200, 210, 10, rng);
            const sx = Math.floor(rng()*14)+1, sy = Math.floor(rng()*14)+1;
            ctx.fillRect(sx, sy, 2, 2);
        }
    });

    // Gold ore - stone with gold flecks
    blockTextures.gold = makeTexture(ctx => {
        fillPixelNoise(ctx, 0x9E9E9E, 15, rng);
        for (let i = 0; i < 8; i++) {
            ctx.fillStyle = varyColor(255, 200, 0, 15, rng);
            const sx = Math.floor(rng()*14)+1, sy = Math.floor(rng()*14)+1;
            ctx.fillRect(sx, sy, 2, 2);
        }
    });

    // Crystal - cyan with sparkle
    blockTextures.crystal = makeTexture(ctx => {
        const cyans = [0x00BCD4, 0x00ACC1, 0x0097A7, 0x26C6DA];
        for (let y = 0; y < TEX_SIZE; y++) {
            for (let x = 0; x < TEX_SIZE; x++) {
                const base = cyans[Math.floor(rng() * cyans.length)];
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 20, rng);
                ctx.fillRect(x, y, 1, 1);
            }
        }
        // White sparkle pixels
        for (let i = 0; i < 6; i++) {
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.fillRect(Math.floor(rng()*TEX_SIZE), Math.floor(rng()*TEX_SIZE), 1, 1);
        }
    });

    // Planks - horizontal wood grain
    blockTextures.planks = makeTexture(ctx => {
        const tans = [0xD7A86E, 0xC9975C, 0xE0B87E, 0xBF8A50];
        for (let y = 0; y < TEX_SIZE; y++) {
            const base = tans[Math.floor(y / 4) % tans.length];
            for (let x = 0; x < TEX_SIZE; x++) {
                const [r, g, b] = hexToRgb(base);
                ctx.fillStyle = varyColor(r, g, b, 10, rng);
                ctx.fillRect(x, y, 1, 1);
            }
            // Plank divider line
            if (y % 4 === 0) {
                for (let x = 0; x < TEX_SIZE; x++) {
                    ctx.fillStyle = varyColor(140, 100, 50, 8, rng);
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    });

    // Paper
    blockTextures.paper = makeTexture(ctx => {
        fillPixelNoise(ctx, 0xF5F5DC, 8, rng);
        // Faint lines
        for (let y = 3; y < TEX_SIZE; y += 4) {
            for (let x = 0; x < TEX_SIZE; x++) {
                ctx.fillStyle = 'rgba(180,180,160,0.4)';
                ctx.fillRect(x, y, 1, 1);
            }
        }
    });

    // Blog post - pinkish with text lines
    blockTextures.blogpost = makeTexture(ctx => {
        fillPixelNoise(ctx, 0xE91E63, 15, rng);
        // White text lines
        for (let y = 3; y < TEX_SIZE; y += 3) {
            for (let x = 2; x < 14; x++) {
                if (rng() > 0.3) {
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    });
}

function getBlockMaterial(type) {
    const b = BLOCKS[type];
    if (!b) return new THREE.MeshLambertMaterial({ color: 0xff00ff });

    if (type === 'grass') {
        const topMat = new THREE.MeshLambertMaterial({ map: blockTextures.grass_top });
        const sideMat = new THREE.MeshLambertMaterial({ map: blockTextures.grass_side });
        const bottomMat = new THREE.MeshLambertMaterial({ map: blockTextures.dirt });
        return [sideMat, sideMat, topMat, bottomMat, sideMat, sideMat];
    }
    if (type === 'wood') {
        const sideMat = new THREE.MeshLambertMaterial({ map: blockTextures.wood });
        const topMat = new THREE.MeshLambertMaterial({ map: blockTextures.wood_top });
        return [sideMat, sideMat, topMat, topMat, sideMat, sideMat];
    }
    if (type === 'leaves') {
        return new THREE.MeshLambertMaterial({ map: blockTextures.leaves, transparent: true, opacity: 0.9 });
    }

    // For types with a matching texture
    const texKey = type;
    if (blockTextures[texKey]) {
        return new THREE.MeshLambertMaterial({ map: blockTextures[texKey] });
    }

    return new THREE.MeshLambertMaterial({ color: b.color });
}

// Material cache
const materialCache = {};
function getCachedMaterial(type) {
    if (!materialCache[type]) materialCache[type] = getBlockMaterial(type);
    return materialCache[type];
}

function addBlock(x, y, z, type) {
    const key = `${x},${y},${z}`;
    world[key] = type;
    const mesh = new THREE.Mesh(blockGeo, getCachedMaterial(type));
    mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
    mesh.userData = { bx: x, by: y, bz: z, type: type };
    scene.add(mesh);
    blockMeshes[key] = mesh;
}

function removeBlock(x, y, z) {
    const key = `${x},${y},${z}`;
    delete world[key];
    if (blockMeshes[key]) {
        scene.remove(blockMeshes[key]);
        delete blockMeshes[key];
    }
}

function generateWorld() {
    const rng = mulberry32(42); // seeded RNG for consistent world

    for (let x = 0; x < WORLD_SIZE; x++) {
        for (let z = 0; z < WORLD_SIZE; z++) {
            // Bedrock / stone layer
            addBlock(x, 0, z, 'stone');
            // Dirt layer
            addBlock(x, 1, z, 'dirt');
            // Grass top
            addBlock(x, 2, z, 'grass');

            // Scatter ore in stone layer
            const oreRoll = rng();
            if (oreRoll < 0.03) {
                removeBlock(x, 0, z);
                addBlock(x, 0, z, 'gold');
            } else if (oreRoll < 0.08) {
                removeBlock(x, 0, z);
                addBlock(x, 0, z, 'iron');
            } else if (oreRoll < 0.10) {
                removeBlock(x, 0, z);
                addBlock(x, 0, z, 'crystal');
            }
        }
    }

    // Generate trees
    for (let i = 0; i < 20; i++) {
        const tx = Math.floor(rng() * (WORLD_SIZE - 4)) + 2;
        const tz = Math.floor(rng() * (WORLD_SIZE - 4)) + 2;
        const height = 3 + Math.floor(rng() * 3);

        // Trunk
        for (let h = 0; h < height; h++) {
            addBlock(tx, 3 + h, tz, 'wood');
        }
        // Leaves (canopy)
        const topY = 3 + height;
        for (let dx = -2; dx <= 2; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue; // corners
                    const lx = tx + dx, ly = topY + dy, lz = tz + dz;
                    if (lx < 0 || lx >= WORLD_SIZE || lz < 0 || lz >= WORLD_SIZE) continue;
                    const lk = `${lx},${ly},${lz}`;
                    if (!world[lk]) addBlock(lx, ly, lz, 'leaves');
                }
            }
        }
    }
}

// Seeded RNG
function mulberry32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

// ============================================
// INVENTORY & HOTBAR
// ============================================
function addToInventory(type, count) {
    // Try to stack in existing hotbar slot
    for (let i = 0; i < 9; i++) {
        if (hotbar[i] && hotbar[i].type === type) {
            hotbar[i].count += count;
            renderHotbar();
            return;
        }
    }
    // Find empty slot
    for (let i = 0; i < 9; i++) {
        if (!hotbar[i]) {
            hotbar[i] = { type, count };
            renderHotbar();
            return;
        }
    }
    // Hotbar full - still track in overflow inventory
    inventory[type] = (inventory[type] || 0) + count;
    showNotif('Hotbar full! Item stored in inventory.');
    renderHotbar();
}

function removeFromHotbar(slot) {
    if (!hotbar[slot]) return false;
    hotbar[slot].count--;
    if (hotbar[slot].count <= 0) hotbar[slot] = null;
    renderHotbar();
    return true;
}

function countItem(type) {
    let c = 0;
    for (let i = 0; i < 9; i++) {
        if (hotbar[i] && hotbar[i].type === type) c += hotbar[i].count;
    }
    c += (inventory[type] || 0);
    return c;
}

function consumeItem(type, amount) {
    let remaining = amount;
    // Take from hotbar first
    for (let i = 0; i < 9; i++) {
        if (remaining <= 0) break;
        if (hotbar[i] && hotbar[i].type === type) {
            const take = Math.min(remaining, hotbar[i].count);
            hotbar[i].count -= take;
            remaining -= take;
            if (hotbar[i].count <= 0) hotbar[i] = null;
        }
    }
    // Then from overflow
    if (remaining > 0 && inventory[type]) {
        const take = Math.min(remaining, inventory[type]);
        inventory[type] -= take;
        remaining -= take;
    }
    renderHotbar();
}

function renderHotbar() {
    const bar = document.getElementById('hotbar');
    bar.innerHTML = '';
    for (let i = 0; i < 9; i++) {
        const slot = document.createElement('div');
        slot.className = 'hotbar-slot' + (i === selectedSlot ? ' selected' : '');
        slot.onclick = () => { selectedSlot = i; renderHotbar(); };

        const keyLabel = document.createElement('div');
        keyLabel.className = 'slot-key';
        keyLabel.textContent = i + 1;
        slot.appendChild(keyLabel);

        if (hotbar[i]) {
            const swatch = document.createElement('div');
            swatch.className = 'slot-color';
            const type = hotbar[i].type;
            // Use canvas texture if available
            const texKey = (type === 'grass') ? 'grass_top' : (type === 'wood') ? 'wood' : type;
            if (blockTextures[texKey] && blockTextures[texKey].image) {
                swatch.style.background = 'none';
                swatch.style.imageRendering = 'pixelated';
                swatch.style.backgroundImage = `url(${blockTextures[texKey].image.toDataURL()})`;
                swatch.style.backgroundSize = 'cover';
            } else {
                const b = BLOCKS[type];
                swatch.style.background = '#' + (b ? b.color.toString(16).padStart(6, '0') : 'ff00ff');
            }
            slot.appendChild(swatch);

            const cnt = document.createElement('div');
            cnt.className = 'slot-count';
            cnt.textContent = hotbar[i].count;
            slot.appendChild(cnt);
        }
        bar.appendChild(slot);
    }
}

// ============================================
// BLOCK INTERACTION
// ============================================
function getTargetBlock() {
    const center = new THREE.Vector2(0, 0);
    raycaster.setFromCamera(center, camera);
    const meshes = Object.values(blockMeshes);
    const hits = raycaster.intersectObjects(meshes);
    if (hits.length > 0) return hits[0];
    return null;
}

function mineBlock() {
    const hit = getTargetBlock();
    if (!hit) return;
    const d = hit.object.userData;
    const type = d.type;

    // Remove block from world
    removeBlock(d.bx, d.by, d.bz);
    // Add to inventory
    addToInventory(type, 1);
    saveState();
}

function placeBlock() {
    if (!hotbar[selectedSlot]) return;
    const hit = getTargetBlock();
    if (!hit) return;

    // Calculate placement position from face normal
    const normal = hit.face.normal;
    const d = hit.object.userData;
    const px = d.bx + Math.round(normal.x);
    const py = d.by + Math.round(normal.y);
    const pz = d.bz + Math.round(normal.z);

    // Don't place inside player
    const camX = Math.floor(camera.position.x);
    const camY1 = Math.floor(camera.position.y);
    const camY2 = Math.floor(camera.position.y - 1);
    const camZ = Math.floor(camera.position.z);
    if (px === camX && pz === camZ && (py === camY1 || py === camY2)) return;

    // Don't place outside world bounds
    if (px < 0 || px >= WORLD_SIZE || pz < 0 || pz >= WORLD_SIZE || py < 0 || py >= WORLD_HEIGHT + 10) return;

    const key = `${px},${py},${pz}`;
    if (world[key]) return; // Already occupied

    const type = hotbar[selectedSlot].type;
    // Don't place non-block items
    if (type === 'blogpost' || type === 'paper') return;

    addBlock(px, py, pz, type);
    removeFromHotbar(selectedSlot);
    saveState();
}

// ============================================
// CRAFTING
// ============================================
function toggleCraft() {
    craftOpen = !craftOpen;
    document.getElementById('craft-panel').classList.toggle('open', craftOpen);
    if (craftOpen) { selectedRecipe = 0; renderCraftPanel(); }
}

function scrollRecipeIntoView() {
    const items = document.querySelectorAll('#recipe-list .recipe');
    if (items[selectedRecipe]) items[selectedRecipe].scrollIntoView({ block: 'nearest' });
}

function renderCraftPanel() {
    const list = document.getElementById('recipe-list');
    list.innerHTML = '';

    RECIPES.forEach((recipe, idx) => {
        const div = document.createElement('div');
        div.className = 'recipe' + (idx === selectedRecipe ? ' selected-recipe' : '');

        let canCraft = true;
        let matsHtml = '';
        for (const [type, amt] of Object.entries(recipe.inputs)) {
            const have = countItem(type);
            const enough = have >= amt;
            if (!enough) canCraft = false;
            const b = BLOCKS[type];
            const name = b ? b.name : type;
            matsHtml += `<span class="${enough ? 'has' : 'miss'}">${name}: ${have}/${amt}</span> `;
        }

        // Special checks
        let resultText = '';
        if (recipe.special === 'pickaxe_stone') {
            resultText = 'Equip: +50% mine speed';
            if (pickaxeLevel >= 1) { canCraft = false; resultText = 'Already owned'; }
        } else if (recipe.special === 'pickaxe_iron') {
            resultText = 'Equip: +100% mine speed';
            if (pickaxeLevel >= 2) { canCraft = false; resultText = 'Already owned'; }
        } else if (recipe.special === 'publish') {
            const rank = getRankIndex();
            const mult = 1 + rank * 0.5;
            const minF = Math.floor(10 * mult);
            const maxF = Math.floor(50 * mult);
            resultText = `Earns ${minF}-${maxF} followers + coins`;
        } else {
            const outEntries = Object.entries(recipe.outputs);
            if (outEntries.length > 0) {
                resultText = outEntries.map(([t, c]) => `${c}x ${BLOCKS[t] ? BLOCKS[t].name : t}`).join(', ');
            }
        }

        div.innerHTML = `
            <div class="recipe-info">
                <div class="recipe-name">${recipe.name}</div>
                <div class="recipe-mats">${matsHtml}</div>
                ${resultText ? `<div class="recipe-result">${resultText}</div>` : ''}
            </div>
        `;

        const btn = document.createElement('button');
        btn.className = 'craft-btn';
        btn.disabled = !canCraft;
        btn.textContent = 'Craft';
        btn.onclick = () => doCraft(idx);
        div.appendChild(btn);

        list.appendChild(div);
    });
}

function doCraft(idx) {
    const recipe = RECIPES[idx];

    // Verify and consume inputs
    for (const [type, amt] of Object.entries(recipe.inputs)) {
        if (countItem(type) < amt) return;
    }
    for (const [type, amt] of Object.entries(recipe.inputs)) {
        consumeItem(type, amt);
    }

    // Handle special recipes
    if (recipe.special === 'pickaxe_stone') {
        pickaxeLevel = Math.max(pickaxeLevel, 1);
        showNotif('Crafted Stone Pickaxe! Mining is faster.');
    } else if (recipe.special === 'pickaxe_iron') {
        pickaxeLevel = Math.max(pickaxeLevel, 2);
        showNotif('Crafted Iron Pickaxe! Mining is much faster.');
    } else if (recipe.special === 'publish') {
        const rank = getRankIndex();
        const mult = 1 + rank * 0.5;
        const gained = Math.floor((10 + Math.random() * 40) * mult);
        const coins = Math.floor(2 + Math.random() * 8 * mult);
        followers += gained;
        currentUser.coins = (currentUser.coins || 0) + coins;
        localStorage.setItem('user', JSON.stringify(currentUser));
        syncCoins();
        updateHUD();
        showNotif(`Published! +${gained} followers, +${coins} coins`);
    } else {
        // Normal recipe - add outputs
        for (const [type, count] of Object.entries(recipe.outputs)) {
            addToInventory(type, count);
        }
        showNotif('Crafted ' + recipe.name + '!');
    }

    saveState();
    renderCraftPanel();
}

function getRankIndex() {
    for (let i = RANKS.length - 1; i >= 0; i--) {
        if (followers >= RANKS[i].followers) return i;
    }
    return 0;
}

// ============================================
// HUD
// ============================================
function updateHUD() {
    document.getElementById('d-coins').textContent = currentUser.coins || 0;
    document.getElementById('d-followers').textContent = followers;
    document.getElementById('d-rank').textContent = RANKS[getRankIndex()].name;
}

function showNotif(text) {
    const el = document.createElement('div');
    el.className = 'notif';
    el.textContent = text;
    document.body.appendChild(el);
    setTimeout(() => { el.style.opacity = '0'; el.style.transition = 'opacity 0.5s'; }, 2000);
    setTimeout(() => el.remove(), 2500);
}

function syncCoins() {
    fetch(API_URL + '/user/coins', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + authToken },
        body: JSON.stringify({ coins: currentUser.coins }),
    }).catch(() => {});
}

// ============================================
// SAVE / LOAD
// ============================================
function saveState() {
    const s = {
        world: world,
        hotbar: hotbar,
        inventory: inventory,
        followers: followers,
        pickaxeLevel: pickaxeLevel,
        camPos: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
        camRot: { x: euler.x, y: euler.y },
    };
    localStorage.setItem('blogcraft3d', JSON.stringify(s));
}

function loadState() {
    const raw = localStorage.getItem('blogcraft3d');
    if (!raw) return false;
    const s = JSON.parse(raw);

    // Clear existing world
    for (const key in blockMeshes) {
        scene.remove(blockMeshes[key]);
    }
    blockMeshes = {};
    world = {};

    // Rebuild world from save
    for (const [key, type] of Object.entries(s.world)) {
        const [x, y, z] = key.split(',').map(Number);
        addBlock(x, y, z, type);
    }

    hotbar = s.hotbar || [null,null,null,null,null,null,null,null,null];
    inventory = s.inventory || {};
    followers = s.followers || 0;
    pickaxeLevel = s.pickaxeLevel || 0;

    if (s.camPos) camera.position.set(s.camPos.x, s.camPos.y, s.camPos.z);
    if (s.camRot) { euler.x = s.camRot.x; euler.y = s.camRot.y; }

    return true;
}

// ============================================
// PHYSICS / MOVEMENT
// ============================================
function getBlock(x, y, z) {
    return world[`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`];
}

function isColliding(px, py, pz) {
    // Check player bounding box (0.3 radius, 1.7 height)
    const r = 0.3;
    for (let dx = -r; dx <= r; dx += r * 2) {
        for (let dz = -r; dz <= r; dz += r * 2) {
            for (let dy = 0; dy < playerHeight; dy += 0.8) {
                if (getBlock(px + dx, py - playerHeight + dy, pz + dz)) return true;
            }
        }
    }
    return false;
}

function updatePhysics(delta) {
    if (craftOpen) return;

    // Gravity
    velocity.y -= 20 * delta;

    // Movement direction
    const direction = new THREE.Vector3();
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

    const speed = 5;
    if (moveForward) direction.add(forward);
    if (moveBackward) direction.sub(forward);
    if (moveRight) direction.add(right);
    if (moveLeft) direction.sub(right);

    if (direction.length() > 0) direction.normalize();
    direction.multiplyScalar(speed * delta);

    // Try X movement
    const newX = camera.position.x + direction.x;
    if (!isColliding(newX, camera.position.y, camera.position.z)) {
        camera.position.x = newX;
    }

    // Try Z movement
    const newZ = camera.position.z + direction.z;
    if (!isColliding(camera.position.x, camera.position.y, newZ)) {
        camera.position.z = newZ;
    }

    // Y movement (gravity + jump)
    const newY = camera.position.y + velocity.y * delta;
    if (!isColliding(camera.position.x, newY, camera.position.z)) {
        camera.position.y = newY;
        canJump = false;
    } else {
        if (velocity.y < 0) canJump = true;
        velocity.y = 0;
    }

    // Floor clamp
    if (camera.position.y < playerHeight + 0.1) {
        camera.position.y = playerHeight + 0.1;
        canJump = true;
        velocity.y = 0;
    }

    // World bounds
    camera.position.x = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, camera.position.x));
    camera.position.z = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, camera.position.z));
}

// ============================================
// CONTROLS - KEYBOARD
// ============================================
document.addEventListener('keydown', (e) => {
    if (craftOpen) {
        switch (e.code) {
            case 'ArrowUp':
                e.preventDefault();
                selectedRecipe = Math.max(0, selectedRecipe - 1);
                renderCraftPanel();
                scrollRecipeIntoView();
                return;
            case 'ArrowDown':
                e.preventDefault();
                selectedRecipe = Math.min(RECIPES.length - 1, selectedRecipe + 1);
                renderCraftPanel();
                scrollRecipeIntoView();
                return;
            case 'Enter':
                e.preventDefault();
                doCraft(selectedRecipe);
                return;
            case 'KeyE': case 'Escape':
                toggleCraft();
                return;
        }
        return;
    }
    switch (e.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space':
            e.preventDefault();
            if (canJump) { velocity.y = 8; canJump = false; }
            break;
        case 'KeyE': toggleCraft(); break;
        case 'Escape':
            if (craftOpen) toggleCraft();
            break;
        case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4': case 'Digit5':
        case 'Digit6': case 'Digit7': case 'Digit8': case 'Digit9':
            selectedSlot = parseInt(e.code.replace('Digit', '')) - 1;
            renderHotbar();
            break;
    }
});

document.addEventListener('keyup', (e) => {
    switch (e.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyD': moveRight = false; break;
    }
});

// ============================================
// CONTROLS - MOUSE (POINTER LOCK)
// ============================================
const canvas = renderer.domElement;

document.getElementById('start-overlay').addEventListener('click', () => {
    if (isTouchDevice) {
        document.getElementById('start-overlay').classList.add('hidden');
    } else {
        canvas.requestPointerLock();
    }
});

canvas.addEventListener('click', () => {
    if (!isTouchDevice && !isPointerLocked) {
        canvas.requestPointerLock();
    }
});

document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === canvas;
    if (!isTouchDevice) {
        document.getElementById('start-overlay').classList.toggle('hidden', isPointerLocked);
    }
});

document.addEventListener('mousemove', (e) => {
    if (!isTouchDevice && !isPointerLocked) return;
    const sensitivity = 0.002;
    euler.y -= e.movementX * sensitivity;
    euler.x -= e.movementY * sensitivity;
    euler.x = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, euler.x));
    camera.quaternion.setFromEuler(euler);
});

// Mining / Placing
let mouseDown = false;
let mineStartTime = 0;

canvas.addEventListener('mousedown', (e) => {
    if (!isTouchDevice && !isPointerLocked) return;
    e.preventDefault();
    if (craftOpen) return;

    if (e.button === 0) {
        // Left click - mine
        mouseDown = true;
        mineStartTime = performance.now();
        document.getElementById('mine-progress').style.display = 'block';
    } else if (e.button === 2) {
        // Right click - place
        placeBlock();
    }
});

canvas.addEventListener('mouseup', (e) => {
    if (e.button === 0) {
        mouseDown = false;
        document.getElementById('mine-progress').style.display = 'none';
        document.getElementById('mine-progress-fill').style.width = '0%';
    }
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// ============================================
// CONTROLS - TOUCH (MOBILE)
// ============================================
let touchJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
let touchLook = { active: false, id: null, lastX: 0, lastY: 0 };

const joystickArea = document.getElementById('joystick-area');
const joystickKnob = document.getElementById('joystick-knob');

if (joystickArea) {
    joystickArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const t = e.changedTouches[0];
        touchJoystick.active = true;
        touchJoystick.startX = t.clientX;
        touchJoystick.startY = t.clientY;
        touchJoystick.id = t.identifier;
        // Hide start overlay on mobile
        document.getElementById('start-overlay').classList.add('hidden');
    });

    joystickArea.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (const t of e.changedTouches) {
            if (t.identifier === touchJoystick.id) {
                const dx = t.clientX - touchJoystick.startX;
                const dy = t.clientY - touchJoystick.startY;
                const maxDist = 40;
                const dist = Math.min(Math.sqrt(dx * dx + dy * dy), maxDist);
                const angle = Math.atan2(dy, dx);
                touchJoystick.dx = Math.cos(angle) * dist / maxDist;
                touchJoystick.dy = Math.sin(angle) * dist / maxDist;
                joystickKnob.style.transform = `translate(${-50 + touchJoystick.dx * 40}%, ${-50 + touchJoystick.dy * 40}%)`;
            }
        }
    });

    joystickArea.addEventListener('touchend', (e) => {
        for (const t of e.changedTouches) {
            if (t.identifier === touchJoystick.id) {
                touchJoystick.active = false;
                touchJoystick.dx = 0;
                touchJoystick.dy = 0;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }
        }
    });
}

// Touch look (right side of screen)
canvas.addEventListener('touchstart', (e) => {
    // Dismiss start overlay on any canvas touch
    document.getElementById('start-overlay').classList.add('hidden');
    for (const t of e.changedTouches) {
        if (t.clientX > window.innerWidth / 2) {
            touchLook.active = true;
            touchLook.id = t.identifier;
            touchLook.lastX = t.clientX;
            touchLook.lastY = t.clientY;
        }
    }
});

canvas.addEventListener('touchmove', (e) => {
    for (const t of e.changedTouches) {
        if (t.identifier === touchLook.id) {
            const dx = t.clientX - touchLook.lastX;
            const dy = t.clientY - touchLook.lastY;
            euler.y -= dx * 0.005;
            euler.x -= dy * 0.005;
            euler.x = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, euler.x));
            camera.quaternion.setFromEuler(euler);
            touchLook.lastX = t.clientX;
            touchLook.lastY = t.clientY;
        }
    }
});

canvas.addEventListener('touchend', (e) => {
    for (const t of e.changedTouches) {
        if (t.identifier === touchLook.id) {
            touchLook.active = false;
            // Quick tap = mine
            mineBlock();
        }
    }
});

// Mobile buttons
const btnJump = document.getElementById('btn-jump');
const btnPlace = document.getElementById('btn-place');
const btnCraft = document.getElementById('btn-craft');

if (btnJump) btnJump.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (canJump) { velocity.y = 8; canJump = false; }
});
if (btnPlace) btnPlace.addEventListener('touchstart', (e) => {
    e.preventDefault();
    placeBlock();
});
if (btnCraft) btnCraft.addEventListener('touchstart', (e) => {
    e.preventDefault();
    toggleCraft();
});

// ============================================
// GAME LOOP
// ============================================
const clock = new THREE.Clock();
let saveTimer = 0;

function animate() {
    requestAnimationFrame(animate);
    const delta = Math.min(clock.getDelta(), 0.1);

    // Mobile joystick movement
    if (isTouchDevice) {
        if (touchJoystick.active) {
            moveForward = touchJoystick.dy < -0.3;
            moveBackward = touchJoystick.dy > 0.3;
            moveLeft = touchJoystick.dx < -0.3;
            moveRight = touchJoystick.dx > 0.3;
        } else {
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
        }
    }

    updatePhysics(delta);

    // Mining progress (hold left click)
    if (mouseDown && !craftOpen) {
        const elapsed = performance.now() - mineStartTime;
        const duration = miningDuration / (1 + pickaxeLevel * 0.5);
        const pct = Math.min(elapsed / duration, 1);
        document.getElementById('mine-progress-fill').style.width = (pct * 100) + '%';
        if (pct >= 1) {
            mineBlock();
            mineStartTime = performance.now();
        }
    }

    // Auto-save
    saveTimer += delta;
    if (saveTimer > 30) {
        saveTimer = 0;
        saveState();
    }

    renderer.render(scene, camera);
}

// ============================================
// RESIZE
// ============================================
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============================================
// INIT
// ============================================
function init() {
    checkAuth();
    genTextures();
    const loaded = loadState();
    if (!loaded) generateWorld();
    // Also clear old tab-based state
    localStorage.removeItem('blogcraft_state');
    renderHotbar();
    updateHUD();
    animate();
}

init();
</script>
</body>
</html>
